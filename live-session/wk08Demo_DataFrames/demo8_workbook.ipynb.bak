{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# DO NOT RUN THIS NOTEBOOK"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# wk8 Demo - Advanced Spark - Pipelines and Optimizations with DataFrames\n",
    "__`MIDS w261: Machine Learning at Scale | UC Berkeley School of Information | Spring 2019`__\n",
    "\n",
    "So far we've been using Spark's low level APIs. In particular, we've been using the RDD (Resilient Distiributed Datasets) API to implement Machine Learning algorithms from scratch. This week we're going to take a look at how Spark is used in a production setting. We'll look at DataFrames, SQL, and UDFs (User Defined Functions).  As discussed previously, we still need to understand the internals of Spark and MapReduce in general to write efficient and scalable code.\n",
    "\n",
    "In class today we'll get some practice working with larger data sets in Spark. We'll start with an introduction to efficiently storing data and approach a large dataset for analysis. After that we'll discuss a ranking problem which was covered in Chapter 6 of the High Performance Spark book and how we can apply that to our problem. We'll follow up with a discussion on things that could be done to make this more effiicent.\n",
    "* ... __describe__ differences between data serialization formats.\n",
    "* ... __choose__ a data serialization format based on use case.\n",
    "* ... __change__ submission arguements for a `SparkSession`.\n",
    "* ... __set__ custom configuration for a `SparkSession`.\n",
    "* ... __describe__ and __create__ a data pipeline for analysis.\n",
    "* ... __use__ a user defined function (UDF).\n",
    "* ... __understand__ feature engineering and aggregations in Spark.\n",
    "\n",
    "__`Additional Resources:`__ Writing performant code in Spark requires a lot of thought. Holden's High Performance Spark book covers this topic very well"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Notebook Set-Up"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This is running on dataproc with the following setup\n",
    "\n",
    "```{bash}\n",
    "BUCKET=\"w261-data\"\n",
    "CLUSTER=\"w261-wk06\"\n",
    "PROJECT=\"w261-166920\"\n",
    "JUPYTER_PORT=\"8123\"\n",
    "PORT=\"10000\"\n",
    "ZONE=$(gcloud config get-value compute/zone)\n",
    "\n",
    "# CREATE DATAPROC CLUSTER\n",
    "gcloud dataproc clusters create ${CLUSTER} \\\n",
    "    --metadata \"JUPYTER_PORT=${JUPYTER_PORT}\" \\\n",
    "    --metadata \"JUPYTER_CONDA_PACKAGES=numpy:pandas:scipy:pyarrow\" \\\n",
    "    --metadata \"JUPYTER_CONDA_CHANNELS=conda-forge\" \\\n",
    "    --project ${PROJECT} \\\n",
    "    --bucket ${BUCKET} \\\n",
    "    --image-version \"1.3.10-deb9\" \\\n",
    "    --initialization-actions \\\n",
    "       gs://dataproc-initialization-actions/jupyter/jupyter.sh \\\n",
    "    --num-preemptible-workers=4 \\\n",
    "    --num-workers=2 \\\n",
    "    --worker-machine-type=n1-standard-8 \\\n",
    "    --master-machine-type=n1-standard-8\n",
    "    \n",
    "# CREATE SOCKS PROXY\n",
    "gcloud compute ssh ${CLUSTER}-m \\\n",
    "    --project=${PROJECT} --zone=${ZONE}  -- \\\n",
    "    -D ${PORT} -N\n",
    "\n",
    "# USE SOCKS PROXY\n",
    "/usr/bin/google-chrome \\\n",
    "  --proxy-server=\"socks5://localhost:${PORT}\" \\\n",
    "  --user-data-dir=/tmp/${CLUSTER}-m    \n",
    "\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "# imports\n",
    "import re\n",
    "import os\n",
    "import numpy as np\n",
    "import pandas as pd"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Load the data\n",
    "Today we'll be using GSOD weather station data, avaliable from Google in BigQuery.\n",
    "\n",
    "Since this is a decent sized dataset (21 GB uncompressed) we won't be running code, but rather reviewing the process."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Waiting on bqjob_r585f1a19a17059c2_0000016656ac5460_1 ... (47s) Current status: DONE   \n",
      "Waiting on bqjob_r73a654dc7b0b6759_0000016656ad1c42_1 ... (1s) Current status: DONE   \n"
     ]
    }
   ],
   "source": [
    "# Get data from BigQuery into Google Cloud Storage as GZIP compressed CSV files\n",
    "!bq --location=US extract --compression GZIP 'bigquery-public-data:samples.gsod' gs://w261-data/gsod/gsod-*.csv.gz\n",
    "!bq --location=US extract --compression GZIP 'bigquery-public-data:noaa_gsod.stations' gs://w261-data/gsod/stations.csv.gz"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Initialize Spark"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "\n",
       "            <div>\n",
       "                <p><b>SparkSession - hive</b></p>\n",
       "                \n",
       "        <div>\n",
       "            <p><b>SparkContext</b></p>\n",
       "\n",
       "            <p><a href=\"http://w261-wk06-m.c.w261-166920.internal:4040\">Spark UI</a></p>\n",
       "\n",
       "            <dl>\n",
       "              <dt>Version</dt>\n",
       "                <dd><code>v2.3.1</code></dd>\n",
       "              <dt>Master</dt>\n",
       "                <dd><code>yarn</code></dd>\n",
       "              <dt>AppName</dt>\n",
       "                <dd><code>pyspark-shell</code></dd>\n",
       "            </dl>\n",
       "        </div>\n",
       "        \n",
       "            </div>\n",
       "        "
      ],
      "text/plain": [
       "<pyspark.sql.session.SparkSession at 0x7fbae8631f60>"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "spark"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Here we show how to do a custom configuration\n",
    "sc = spark.sparkContext"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "from pyspark.sql import SQLContext\n",
    "sqlContext = SQLContext(sc)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[('spark.driver.extraJavaOptions',\n",
       "  '-Dflogger.backend_factory=com.google.cloud.hadoop.repackaged.gcs.com.google.common.flogger.backend.log4j.Log4jBackendFactory#getInstance'),\n",
       " ('spark.eventLog.enabled', 'true'),\n",
       " ('spark.dynamicAllocation.minExecutors', '1'),\n",
       " ('spark.org.apache.hadoop.yarn.server.webproxy.amfilter.AmIpFilter.param.PROXY_URI_BASES',\n",
       "  'http://w261-wk06-m:8088/proxy/application_1539056016518_0001'),\n",
       " ('spark.yarn.am.memory', '640m'),\n",
       " ('spark.yarn.historyServer.address', 'w261-wk06-m:18080'),\n",
       " ('spark.executor.cores', '4'),\n",
       " ('spark.ui.proxyBase', '/proxy/application_1539056016518_0001'),\n",
       " ('spark.driver.appUIAddress',\n",
       "  'http://w261-wk06-m.c.w261-166920.internal:4040'),\n",
       " ('spark.app.id', 'application_1539056016518_0001'),\n",
       " ('spark.history.fs.logDirectory', 'hdfs://w261-wk06-m/user/spark/eventlog'),\n",
       " ('spark.executor.instances', '2'),\n",
       " ('spark.serializer.objectStreamReset', '100'),\n",
       " ('spark.driver.maxResultSize', '3840m'),\n",
       " ('spark.submit.deployMode', 'client'),\n",
       " ('spark.ui.filters',\n",
       "  'org.apache.hadoop.yarn.server.webproxy.amfilter.AmIpFilter'),\n",
       " ('spark.org.apache.hadoop.yarn.server.webproxy.amfilter.AmIpFilter.param.PROXY_HOSTS',\n",
       "  'w261-wk06-m'),\n",
       " ('spark.shuffle.service.enabled', 'true'),\n",
       " ('spark.scheduler.mode', 'FAIR'),\n",
       " ('spark.hadoop.hive.execution.engine', 'mr'),\n",
       " ('spark.yarn.jars', 'local:/usr/lib/spark/jars/*'),\n",
       " ('spark.scheduler.minRegisteredResourcesRatio', '0.0'),\n",
       " ('spark.executor.id', 'driver'),\n",
       " ('spark.executor.memory', '11171m'),\n",
       " ('spark.app.name', 'pyspark-shell'),\n",
       " ('spark.dynamicAllocation.maxExecutors', '10000'),\n",
       " ('spark.driver.host', 'w261-wk06-m.c.w261-166920.internal'),\n",
       " ('spark.executor.extraJavaOptions',\n",
       "  '-Dflogger.backend_factory=com.google.cloud.hadoop.repackaged.gcs.com.google.common.flogger.backend.log4j.Log4jBackendFactory#getInstance'),\n",
       " ('spark.master', 'yarn'),\n",
       " ('spark.sql.catalogImplementation', 'hive'),\n",
       " ('spark.executorEnv.PYTHONHASHSEED', '0'),\n",
       " ('spark.rpc.message.maxSize', '512'),\n",
       " ('spark.rdd.compress', 'True'),\n",
       " ('spark.driver.port', '36099'),\n",
       " ('spark.executorEnv.PYTHONPATH',\n",
       "  '/usr/lib/spark/python/:/usr/lib/spark/python/lib/py4j-0.10.7-src.zip<CPS>{{PWD}}/pyspark.zip<CPS>{{PWD}}/py4j-0.10.7-src.zip'),\n",
       " ('spark.executorEnv.OPENBLAS_NUM_THREADS', '1'),\n",
       " ('spark.yarn.isPython', 'true'),\n",
       " ('spark.dynamicAllocation.enabled', 'true'),\n",
       " ('spark.sql.parquet.cacheMetadata', 'false'),\n",
       " ('spark.driver.memory', '7680m'),\n",
       " ('spark.ui.showConsoleProgress', 'true'),\n",
       " ('spark.sql.cbo.enabled', 'true'),\n",
       " ('spark.eventLog.dir', 'hdfs://w261-wk06-m/user/spark/eventlog')]"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sc.getConf().getAll()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Exercise 1. DataFrames and Datasets in Spark\n",
    "\n",
    "A Dataset is a distributed collection of data. Datasets provide the benefits of RDDs (strong typing, ability to use powerful lambda functions) with the benefits of Spark SQL’s optimized execution engine. A Dataset can be constructed from JVM objects and then manipulated using functional transformations (map, flatMap, filter, etc.). The Dataset API is available in Scala and Java. Python does not have the support for the Dataset API. But due to Python’s dynamic nature, many of the benefits of the Dataset API are already available (i.e. you can access the field of a row by name naturally row.columnName). The case for R is similar.\n",
    "\n",
    "A DataFrame is a Dataset organized into named columns. It is conceptually equivalent to a table in a relational database or a data frame in R/Python, but with richer optimizations under the hood. DataFrames can be constructed from a wide array of sources such as: structured data files, tables in Hive, external databases, or existing RDDs. The DataFrame API is available in Scala, Java, Python, and R. In Scala and Java, a DataFrame is represented by a Dataset of Rows. In the Scala API, DataFrame is simply a type alias of Dataset[Row]. While, in Java API, users need to use Dataset<Row> to represent a DataFrame.\n",
    "    \n",
    "This makes the analysis of data similar to how we would do analysis with Python's Pandas or R's dataframes. Spark DataFrames are heavily inspired by Pandas and we're actually able to create Pandas user-defined functions (UDFs) to use with Spark which leverage the Apache Arrow project to vectorized computation instead of row-by-row operations. This can lead to significant performance boosts for large datasets. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " > __DISCUSSION QUESTIONS:__ \n",
    " * _Why would we want to use RDDs in this class over DataFrames?_\n",
    " * _What is a UDF? Why do we need to create them?_\n",
    " * _What is vectorized computation and how does that differ from row-by-row function calls_\n",
    " * _How is a Dataset different than a DataFrame?_\n",
    " * _Are Datasets avaliable in the Python API?_"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " __INSTRUCTOR TALKING POINTS__\n",
    " * _Why would we want to use RDDs in this class over DataFrames?_\n",
    " * _What is a UDF? Why do we need to create them?_\n",
    " * _What is vectorized computation and how does that differ from row-by-row function calls_\n",
    " * _How is a Dataset different than a DataFrame?_\n",
    " * _Are Datasets avaliable in the Python API?_"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Exercise 2. Data Serialization Formats. \n",
    "For week 5 you read [Format Wars](http://www.svds.com/dataformats/) which covered the characteristics, structure, and differences between raw text, sequence, Avro, Parquet, and ORC data serializations. \n",
    "\n",
    "There were several points discussed that \n",
    "\n",
    "* Human Readable\n",
    "* Row vs Column Oriented\n",
    "* Read vs Write performance\n",
    "* Appendable\n",
    "* Splittable (p.113 defintive Guide)\n",
    "* Metadata storage"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Apache Parquet files are a common format directly supported in Spark SQL, and they\n",
    "are incredibly space-efficient and popular. Apache Parquet’s popularity comes from a\n",
    "number of features, including the ability to easily split across multiple files, compression,\n",
    "nested types, and many others discussed in the Parquet documentation. (HP Spark, pg 54)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## First let's understand our data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "����\u0007g}a����(\u0011����\"�rz{�iz�LJky\u0016�\u0002=�\"���;�Y\u0014�\u0005T��_��f���*���qQ �)����\u0003\u00172�]�\u0012\u0016�U������k6\u0019��r:�\u000f*@�oz�^\u0018�\t���\u0017�\u0002Kt�yp��D\u0004w~���$(O ��\u0004�b\u0012S��U\u000f��~��!�t��V���<�\u0014v\"��(\n"
     ]
    }
   ],
   "source": [
    "!head -1 data/gsod-000000000000.csv.gz"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here we see that we have several compressed CSV files as we expect based on our bq command specifying compressions. BigQuery was nice enough to split the files into 30 MB chunks so that our analysis will be partitioned nicely for ingestion.\n",
    "\n",
    "Now let's try to ingest these CSV's without any special commands or unzipped."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "data = spark.read.option(\"header\", \"true\").csv(\"gs://w261-data/gsod/gsod-*.csv.gz\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Row(station_number='39730', wban_number='99999', year='1929', month='11', day='25', mean_temp='49', num_mean_temp_samples='4', mean_dew_point='40.200000762939453', num_mean_dew_point_samples='4', mean_sealevel_pressure=None, num_mean_sealevel_pressure_samples=None, mean_station_pressure=None, num_mean_station_pressure_samples=None, mean_visibility='10.899999618530273', num_mean_visibility_samples='4', mean_wind_speed='19.200000762939453', num_mean_wind_speed_samples='4', max_sustained_wind_speed='36.900001525878906', max_gust_wind_speed=None, max_temperature='46.900001525878906', max_temperature_explicit='true', min_temperature=None, min_temperature_explicit=None, total_precipitation='0', snow_depth=None, fog='false', rain='false', snow='false', hail='false', thunder='false', tornado='false')"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "data.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "root\n",
      " |-- station_number: string (nullable = true)\n",
      " |-- wban_number: string (nullable = true)\n",
      " |-- year: string (nullable = true)\n",
      " |-- month: string (nullable = true)\n",
      " |-- day: string (nullable = true)\n",
      " |-- mean_temp: string (nullable = true)\n",
      " |-- num_mean_temp_samples: string (nullable = true)\n",
      " |-- mean_dew_point: string (nullable = true)\n",
      " |-- num_mean_dew_point_samples: string (nullable = true)\n",
      " |-- mean_sealevel_pressure: string (nullable = true)\n",
      " |-- num_mean_sealevel_pressure_samples: string (nullable = true)\n",
      " |-- mean_station_pressure: string (nullable = true)\n",
      " |-- num_mean_station_pressure_samples: string (nullable = true)\n",
      " |-- mean_visibility: string (nullable = true)\n",
      " |-- num_mean_visibility_samples: string (nullable = true)\n",
      " |-- mean_wind_speed: string (nullable = true)\n",
      " |-- num_mean_wind_speed_samples: string (nullable = true)\n",
      " |-- max_sustained_wind_speed: string (nullable = true)\n",
      " |-- max_gust_wind_speed: string (nullable = true)\n",
      " |-- max_temperature: string (nullable = true)\n",
      " |-- max_temperature_explicit: string (nullable = true)\n",
      " |-- min_temperature: string (nullable = true)\n",
      " |-- min_temperature_explicit: string (nullable = true)\n",
      " |-- total_precipitation: string (nullable = true)\n",
      " |-- snow_depth: string (nullable = true)\n",
      " |-- fog: string (nullable = true)\n",
      " |-- rain: string (nullable = true)\n",
      " |-- snow: string (nullable = true)\n",
      " |-- hail: string (nullable = true)\n",
      " |-- thunder: string (nullable = true)\n",
      " |-- tornado: string (nullable = true)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "data.printSchema()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(114420316, 31)\n"
     ]
    }
   ],
   "source": [
    "print((data.count(), len(data.columns)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Wow that's nice we didn't even have to handle the decompression and it saves a ton on disk space! Next we're going to save this in a few different serializations so that we can see the effect on disk space.\n",
    "\n",
    "Also notice that since we have 114 million observations and 31 columns we should see some huge performance boosts for compression in general and particularly columnar compression with parquet since it takes into account the data type to improve compression further. While row based compression will be less.\n",
    "\n",
    "_Which Data Serialization do you think will do best?_"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### How do these look?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We have 4 data types below\n",
    "\n",
    "- Compressed CSV\n",
    "- Parquet\n",
    "- Avro\n",
    "- CSV\n",
    "\n",
    "Of these 3 are row oriented and 1 is column oriented. We have over 100M rows and 31 columns. Columnar compression should do fairly well in this scenerio. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2.96 GiB    gs://w261-data/gsod/gsod*.csv.gz\n"
     ]
    }
   ],
   "source": [
    "# Our original Compressed data already exists\n",
    "!gsutil du -sh gs://w261-data/gsod/gsod*.csv.gz"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1.61 GiB    gs://w261-data/gsod/data.parquet\n"
     ]
    }
   ],
   "source": [
    "data.write.format(\"parquet\").save(\"gs://w261-data/gsod/data.parquet\")\n",
    "!gsutil du -sh gs://w261-data/gsod/data.parquet"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "6.5G\tdata.avro\n"
     ]
    }
   ],
   "source": [
    "data.write.format(\"com.databricks.spark.avro\").save(\"gs://w261-data/gsod/data.avro\")\n",
    "!gsutil du -sh gs://w261-data/gsod/data.avro"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "21G\tdata.csv\n"
     ]
    }
   ],
   "source": [
    "data.write.format(\"com.databricks.spark.csv\").save('gs://w261-data/gsod/data.csv')\n",
    "!gsutil du -sh gs://w261-data/gsod/data.csv"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### How do these compare for simple computations?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "First we need to read in the data again to ensure we're working with non-cached versions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "data_parquet = spark.read.parquet(\"gs://w261-data/gsod/data.parquet\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Count: \n",
    "Parquet keeps metadata about the data in order to compute some calculations extremely quickly such as row counts"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 4 ms, sys: 0 ns, total: 4 ms\n",
      "Wall time: 3.78 s\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "114420316"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "%%time\n",
    "data_parquet.count()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 5.54 ms, sys: 0 ns, total: 5.54 ms\n",
      "Wall time: 47.8 s\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "114420316"
      ]
     },
     "execution_count": 63,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "%%time\n",
    "data_csv.count()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Average of a column: \n",
    "Parquet is column oriented so it can go through the sequence of data in one step instead of taking each row. This should have much higher performance"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "from pyspark.sql import functions as F"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 12 ms, sys: 0 ns, total: 12 ms\n",
      "Wall time: 8.98 s\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "[Row(avg(max_temperature)=43.51674998177963)]"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "%%time\n",
    "data_parquet.agg(F.avg(data_parquet.max_temperature)).collect()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 7.86 ms, sys: 6.14 ms, total: 14 ms\n",
      "Wall time: 1min 46s\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "[Row(avg(max_temperature)=43.51674998177934)]"
      ]
     },
     "execution_count": 53,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "%%time\n",
    "data.agg(F.avg(data.max_temperature)).collect()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " > __DISCUSSION QUESTIONS:__ For each key term from the reading, briefly explain what it means in the context of this demo code. Specifically:\n",
    " * _What is the compression ratio for the parquet to csv file?_\n",
    " * _Which serialization would query a column faster?_\n",
    " * _Which types of columns do you think has the best compression for parquet?_\n",
    " * _When should you use flat files vs other data formats?_\n",
    " * _If we want to do analysis with lots of aggregations what serialization should we use?_\n",
    " * _Is there any downside to Parquet?_\n",
    " * _If you had to partition data into days as new data comes in with aggregations happening at end of day how would you operationalize this?_"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__INSTRUCTOR TALKING POINTS__\n",
    "* What is the compression ratio for the parquet to csv file?\n",
    "> We have 1.7G/21G = 0.081 or 8.1% of original size\n",
    "\n",
    "* _Which serialization would query a column faster?_\n",
    "> Parquet has a columnar format therefore a column of data has faster access and only needs to grab a subset of data\n",
    "\n",
    "* _Which types of columns do you think has the best compression for parquet?_\n",
    "> Columns with repeated content will have better compressions such as categorical columns will have very high compression ratios, especially if they're integers since parquet has enhanced compression for types with smaller storage requirements.\n",
    "\n",
    "* _When should you use flat files vs other data formats?_\n",
    "> If you need human readable data or you have small data sets\n",
    "\n",
    "* _If we want to do analysis with lots of aggregations what serialization should we use?_\n",
    "> Parquet\n",
    "\n",
    "* _Is there any downside to Parquet?_\n",
    "> Parquet is non-appendable which means that if we have new data coming in we can't grow the dataset with parquet. Parquet datasets are typically used for batch analysis after the data has reached a final state, such as on a date roll-over.\n",
    " \n",
    "* _If you had to partition data into days as new data comes in with aggregations happening at end of day how would you operationalize this?_\n",
    "> Data coming in for a day is streamed into an Avro file which handles appends seamlessly, then once the day has completed and a new partition for data is created a batch job can convert the avro file into a parquet file for the DS/Analyst team to query against."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Exercise 3. Working with DataFrames and simple User-Defined Functions (UDFs)\n",
    "\n",
    "In this example we're going to do some simple analysis of our data using built in spark functions. We'll look into UDFs and use a few instances of them to process our data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Using built-in Spark functions are always more efficient\n",
    "from pyspark.sql import types\n",
    "import pyspark.sql.functions as F\n",
    "\n",
    "timed = data_parquet.withColumn(\"time\", F.concat(F.col(\"year\"), F.lit(\"-\"), F.col(\"month\"), F.lit(\"-\"), F.col(\"day\")).cast(types.TimestampType()))\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "+-------------------+\n",
      "|               time|\n",
      "+-------------------+\n",
      "|1929-12-11 00:00:00|\n",
      "|1930-01-13 00:00:00|\n",
      "|1930-10-07 00:00:00|\n",
      "|1931-09-02 00:00:00|\n",
      "|1931-09-18 00:00:00|\n",
      "+-------------------+\n",
      "only showing top 5 rows\n",
      "\n"
     ]
    }
   ],
   "source": [
    "timed.select('time').show(5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[Row(time=datetime.datetime(1929, 12, 11, 0, 0))]"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "timed.select('time').take(1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {},
   "outputs": [],
   "source": [
    "# A simple UDF for converting year, month, day to timestamps\n",
    "def create_date_from_parts(year, month, day):\n",
    "   return f'{year}-{month}-{day}'\n",
    "\n",
    "create_date_udf = F.udf(create_date_from_parts, types.StringType())\n",
    "timed_udf = data_parquet.withColumn(\"date\", create_date_udf('year', 'month', 'day').cast(types.TimestampType()))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 0 ns, sys: 4 ms, total: 4 ms\n",
      "Wall time: 696 ms\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "[Row(station_number='38110', wban_number='99999', year='1929', month='12', day='11', mean_temp='52.799999237060547', num_mean_temp_samples='4', mean_dew_point='48.5', num_mean_dew_point_samples='4', mean_sealevel_pressure=None, num_mean_sealevel_pressure_samples=None, mean_station_pressure=None, num_mean_station_pressure_samples=None, mean_visibility='5.9000000953674316', num_mean_visibility_samples='4', mean_wind_speed='35.400001525878906', num_mean_wind_speed_samples='4', max_sustained_wind_speed='43.900001525878906', max_gust_wind_speed=None, max_temperature='48', max_temperature_explicit='false', min_temperature=None, min_temperature_explicit=None, total_precipitation=None, snow_depth=None, fog='false', rain='false', snow='false', hail='false', thunder='false', tornado='false', date=datetime.datetime(1929, 12, 11, 0, 0))]"
      ]
     },
     "execution_count": 54,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "%%time\n",
    "timed_udf.take(1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "There's many things we could do from here but there are some important performance considerations when using UDFs. \n",
    "\n",
    "\n",
    "> User-defined functions and user-defined aggregate functions provide you with ways to extend the DataFrame and SQL APIs with your own custom code while keeping the Catalyst optimizer. The Dataset API (see “Datasets” on page 62) is another performant option for much of what you can do with UDFs and UDAFs. This is quite useful for performance, since otherwise you would need to convert the data to an RDD (and potentially back again) to perform arbitrary functions, which is quite expensive. (HP Spark pg 66) \n",
    "\n",
    "\n",
    "UDFs are typically much slower than built-in Spark functionality. The reason for this is becauase they have to serialize and deserialize the data for every row that the function is applied to. There have been recent improvements to UDF for some analytical results with Pandas UDFs that return scalars or groupby maps. Some more information about why UDFs are inefficent can be found here https://blog.cloudera.com/blog/2017/02/working-with-udfs-in-apache-spark/\n",
    "\n",
    "Pandas UDFs solve the serialization issue by vectorizing the inputs and outputs, decreasing the serialziation from 3-100x; however, it isn't a golden bullet. See this blog for details http://garrens.com/blog/2018/03/04/using-new-pyspark-2-3-vectorized-pandas-udfs-lessons/\n",
    "\n",
    "See also: http://sparklingpandas.com/"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<img src=\"https://databricks.com/wp-content/uploads/2017/10/image1-4.png\"/>"
      ],
      "text/plain": [
       "<IPython.core.display.Image object>"
      ]
     },
     "execution_count": 47,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from IPython.display import Image\n",
    "from IPython.core.display import HTML \n",
    "Image(url= \"https://databricks.com/wp-content/uploads/2017/10/image1-4.png\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    ">__DISCUSSION QUESTION:__ \n",
    "* What is the task here? What did we really accomplish?\n",
    "* What type does the UDF create_date_from_parts return?\n",
    "* What information is being stored in the data frame? Is  there anything inefficient about this data structure? \n",
    "* What types of situations would lead to an inefficeint data structure in DataFrames? Could we be more efficient using an RDD in those situations?\n",
    "* What questions would you ask of this table?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__INSTRUCTOR TALKING POINTS__\n",
    "* What is the task here? What did we really accomplish?\n",
    "> We read in data and created a datetime type so we have a single column we can organize data by instead of year, month, day.\n",
    "\n",
    "* What type does the UDF create_date_from_parts return?\n",
    "> String\n",
    "\n",
    "* What information is being stored in the data frame? Is there anything inefficient about this data structure? \n",
    "> The data is mostly numerical. The data is stored effiicently since the DataFrame is mostly populated.\n",
    "\n",
    "* What types of situations would lead to an inefficeint data structure in DataFrames? Could we be more efficient using an RDD in those situations?\n",
    "> Sparse DataFrames have a more efficient data representation in RDDs. An example would be a multi-dimensional cube or pivot table (2d).\n",
    "\n",
    "* What questions would you ask of this table?\n",
    "> Do we have global warming? Let's look at it by looking at average tempertues by latitude have evolved over time."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "UDFs, UDAFs, and Datasets all provide ways to intermix arbitrary code with Spark SQL."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We recommend you write your UDFs in Java or Scala-the small amount of time it atkes to write the function in Java or Scala will always yield significant speed ups. And you can still use the function from within python! (p.113 - Spark, The Definitive Guide)   \n",
    "Scala UDF in python example:   \n",
    "https://medium.com/wbaa/using-scala-udfs-in-pyspark-b70033dd69b9   \n",
    "https://github.com/johnmuller87/spark-udf"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#  Exercise 4. EDA, Data Cleaning, and Vectorized UDFs\n",
    "\n",
    "In this exercise we'll do some basic EDA of our DataFrame, use that to guide some data cleaning, and compare vectorized vs non-vectorized UDFs. Flint does vectorized UDFs out of the box by registering it."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "root\n",
      " |-- station_number: string (nullable = true)\n",
      " |-- wban_number: string (nullable = true)\n",
      " |-- year: string (nullable = true)\n",
      " |-- month: string (nullable = true)\n",
      " |-- day: string (nullable = true)\n",
      " |-- mean_temp: string (nullable = true)\n",
      " |-- num_mean_temp_samples: string (nullable = true)\n",
      " |-- mean_dew_point: string (nullable = true)\n",
      " |-- num_mean_dew_point_samples: string (nullable = true)\n",
      " |-- mean_sealevel_pressure: string (nullable = true)\n",
      " |-- num_mean_sealevel_pressure_samples: string (nullable = true)\n",
      " |-- mean_station_pressure: string (nullable = true)\n",
      " |-- num_mean_station_pressure_samples: string (nullable = true)\n",
      " |-- mean_visibility: string (nullable = true)\n",
      " |-- num_mean_visibility_samples: string (nullable = true)\n",
      " |-- mean_wind_speed: string (nullable = true)\n",
      " |-- num_mean_wind_speed_samples: string (nullable = true)\n",
      " |-- max_sustained_wind_speed: string (nullable = true)\n",
      " |-- max_gust_wind_speed: string (nullable = true)\n",
      " |-- max_temperature: string (nullable = true)\n",
      " |-- max_temperature_explicit: string (nullable = true)\n",
      " |-- min_temperature: string (nullable = true)\n",
      " |-- min_temperature_explicit: string (nullable = true)\n",
      " |-- total_precipitation: string (nullable = true)\n",
      " |-- snow_depth: string (nullable = true)\n",
      " |-- fog: string (nullable = true)\n",
      " |-- rain: string (nullable = true)\n",
      " |-- snow: string (nullable = true)\n",
      " |-- hail: string (nullable = true)\n",
      " |-- thunder: string (nullable = true)\n",
      " |-- tornado: string (nullable = true)\n",
      " |-- time: timestamp (nullable = true)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "timed.printSchema()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "stations = spark.read.option(\"header\", \"true\").csv(\"gs://w261-data/gsod/stations.csv.gz\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "+------+-----+--------------------+-------+-----+----+-----+------+-------+--------+--------+\n",
      "|  usaf| wban|                name|country|state|call|  lat|   lon|   elev|   begin|     end|\n",
      "+------+-----+--------------------+-------+-----+----+-----+------+-------+--------+--------+\n",
      "|007018|99999|WXPOD 7018       ...|   null| null|null|    0|     0|+7018.0|20110309|20130730|\n",
      "|007026|99999|WXPOD 7026       ...|     AF| null|null|    0|     0|+7026.0|20120713|20170822|\n",
      "|007070|99999|WXPOD 7070       ...|     AF| null|null|    0|     0|+7070.0|20140923|20150926|\n",
      "|008268|99999|WXPOD8278        ...|     AF| null|null|32.95|65.567|+1156.7|20100519|20120323|\n",
      "|008307|99999|WXPOD 8318       ...|     AF| null|null|    0|     0|+8318.0|20100421|20100421|\n",
      "+------+-----+--------------------+-------+-----+----+-----+------+-------+--------+--------+\n",
      "only showing top 5 rows\n",
      "\n"
     ]
    }
   ],
   "source": [
    "stations.show(5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Let's filter for just the US since this is a US based dataset\n",
    "stations_us = stations.filter(F.col('Country')=='US')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "^^ this can be very resource intensive. By specifying a function, we are forcing Spark to evaluate this function on every row on our dataset.This can be very computationally intensive. For siple filters it is always preffered to write SQL expressions. (pg 201 - Spark, The Definitive Guide)   "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [],
   "source": [
    "# We need to bring that back to our timed dataframe\n",
    "timed_stations = timed.join(F.broadcast(stations_us), stations_us.usaf==timed.station_number, 'inner')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "^^ Spark will automatically broadcast a small table, it's usually best to let Spark decide. (p.151 Defintive Guide)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Let's only keep what we care about so we minimize our pain\n",
    "keep_columns = ['station_number', 'mean_temp', 'time', 'lat', 'lon']\n",
    "temp = timed_stations.select(*keep_columns)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Let's recast types\n",
    "temp = temp.withColumn(\"mean_temp\", temp[\"mean_temp\"].cast(types.DoubleType()))\n",
    "temp = temp.withColumn(\"lat\", temp[\"lat\"].cast(types.DoubleType()))\n",
    "temp = temp.withColumn(\"lon\", temp[\"lon\"].cast(types.DoubleType()))\n",
    "temp = temp.withColumn(\"station_number\", temp[\"station_number\"].cast(types.IntegerType()))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "+-------+-----------------+------------------+------------------+-------------------+\n",
      "|summary|   station_number|         mean_temp|               lat|                lon|\n",
      "+-------+-----------------+------------------+------------------+-------------------+\n",
      "|  count|       4549924588|        4549924588|        4546004829|         4546004829|\n",
      "|   mean|998203.5812013766|53.702097078852155|39.891780280242834|-100.38080705910738|\n",
      "| stddev| 22161.9524496061|21.449360445676888| 8.898974905414669|  27.31624326579636|\n",
      "|    min|           690014|             -69.0|           -60.483|            -179.63|\n",
      "|    max|           999999|             110.0|              83.7|            179.583|\n",
      "+-------+-----------------+------------------+------------------+-------------------+\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# How is our dataframe looking? We did filter a bunch of data\n",
    "temp.describe().show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Let's look at some of the data in histograms\n",
    "def plot_hist(hist_list):\n",
    "    pd.DataFrame(\n",
    "        list(zip(*hist_list)), \n",
    "        columns=['bin', 'frequency']\n",
    "    ).set_index(\n",
    "        'bin'\n",
    "    ).plot(kind='bar');"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAXcAAAF6CAYAAADiXhggAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADl0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uIDMuMC4wLCBodHRwOi8vbWF0cGxvdGxpYi5vcmcvqOYd8AAAIABJREFUeJztnWm4XFW1td9B6FtpIooBgxCBiDQhIHwoICCNaFBEBEUURFQuCFzFi9cebBCxRUAjF1FRkEYl0is9aiABQuikkTbSSI+AaELG92Ouk1SK05GcVTupzPd56jm79q6qsWqfqllrrzXXmLJNkiRJ0l0s0nQDkiRJkqEng3uSJEkXksE9SZKkC8ngniRJ0oVkcE+SJOlCMrgnSZJ0IY0Gd0knS/qHpJsH8djXSrpE0lRJl0sa0Yk2JkmSLIg03XM/BdhpkI89Fvi57Q2AI4Fv1GpUkiTJgk6jwd32lcATrfskrSXpQknXSbpK0rrl0GjgkrJ9GbBrB5uaJEmyQNF0z703xgMH294E+DRwQtl/I/Cesv1uYDlJKzfQviRJkvmeRZtuQCuSlgX+H3CmpJ7dS5S/nwZ+KOnDwJXA34EZnW5jkiTJgsB8FdyJK4mnbG/UfsD2g8BuMOtH4D22n+5w+5IkSRYI5qthGdvPAPdIei+Agg3L9iqSetr7WeDkhpqZJEky39N0KuRpwF+AdSRNk/QR4APARyTdCNzC7InTbYDbJd0BrAp8rYEmJ0mSLBAoLX+TJEm6j/lqWCZJkiQZGjK4J0mSdCGNZcusssoqHjlyZFPySZIkCyTXXXfdY7aHD/S4xoL7yJEjmTx5clPySZIkCySS7hvM43JYJkmSpAvJ4J4kSdKFZHBPkiTpQuYr+4Hp06czbdo0Xnjhhaab0lUsueSSjBgxgsUWW6zppiRJ0iHmq+A+bdo0lltuOUaOHEmLcVgyD9jm8ccfZ9q0aay55ppNNydJkg4xXw3LvPDCC6y88soZ2IcQSay88sp5NZQkCxnzVXAHMrBXIM9pkix8zHfBvWl+8IMfsN566/GBD3yg6aYkSZLMNfPVmHs7I484b0hf796jdxnwMSeccAIXXHDBHOPTM2bMYNFF5+tTlSTzLfP6PR7M9zZ5Kdlzb+HjH/84d999N+PGjWOFFVbggAMOYIcddmCfffbhxRdf5PDDD2fTTTdlgw024Mc//jEQE5YHHXQQo0ePZpddduHtb387Z511FhCrcB977DEAJk+ezDbbbAPAc889x3777cemm27KxhtvzDnnnAPAKaecwm677cZOO+3EqFGj+MxnPjOrbRdeeCFjxoxhww03ZLvttmPmzJmMGjWKRx99FICZM2ey9tprz9JLkmThJrujLfzoRz/iwgsv5LLLLuOHP/whv//977n66qtZaqmlGD9+PCussAKTJk3i3//+N1tuuSU77LADN9xwA7fffjs33XQTjzzyCKNHj2a//fbrV+drX/sa2267LSeffDJPPfUUm222Gdtvvz0AU6ZM4YYbbmCJJZZgnXXW4eCDD2bJJZfkox/9KFdeeSVrrrkmTzzxBIsssgh77703v/zlLzn00EP54x//yIYbbsgqq6zSiVOVJMl8Tgb3fhg3bhxLLbUUABdffDFTp06d1St/+umnufPOO7nyyivZa6+9GDZsGKutthrbbrvtgK978cUXM2HCBI499lggsoTuv/9+ALbbbjtWWGEFAEaPHs19993Hk08+yVZbbTVrqGillVYCYL/99mPXXXfl0EMP5eSTT2bfffcd2hOQJMkCSwb3flhmmWVmbdvmuOOOY8cdd5zjMeeff36f2SiLLrooM2fOBJgjFdE2Z599Nuuss84cj7/mmmtYYoklZt0fNmwYM2bMwHavGquvvjqrrroql156Kddccw2//OUvX/6bTJKkK8kx90Gy4447cuKJJzJ9+nQA7rjjDp577jm22morTj/9dF588UUeeughLrvsslnPGTlyJNdddx0AZ5999hyvddxxx9FTBeuGG27oV3uLLbbgiiuu4J577gHgiSeemHVs//33Z++992aPPfZg2LBhQ/NmkyRZ4MngPkj2339/Ro8ezZgxY1h//fX52Mc+xowZM3j3u9/NqFGjeOMb38gnPvEJtt5661nP+dKXvsQhhxzCW97yljkC7xe+8AWmT5/OBhtswPrrr88XvvCFfrWHDx/O+PHj2W233dhwww153/veN+vYuHHjePbZZ3NIJkmSOWishurYsWPd7ud+2223sd566zXSnqHiwx/+MO94xzvYfffdO6I3efJkDjvsMK666qp+H9cN5zZZMMlUyKFF0nW2xw70uBxzX4A5+uijOfHEE3OsPUmSl5DBfYg55ZRTOqZ1xBFHcMQRR3RML1mwmZcedPaeFzwGHHOXdLKkf0i6uY/jH5A0tdz+LGnDoW9mkiRJ8nIYzITqKcBO/Ry/B9ja9gbAUcD4eWlQU3MA3Uye0yRZ+BgwuNu+Eniin+N/tv1kuTsRGDG3jVlyySV5/PHHMxgNIT1+7ksuuWTTTUmSpIMM9Zj7R4AL5vbJI0aMYNq0abP8UpKhoacSU5IkCw9DFtwlvZUI7m/u5zEHAAcArLHGGi85vthii2W1oCRJkiFgSBYxSdoAOAnY1fbjfT3O9njbY22PHT58+FBIJ0mSJL0wz8Fd0hrAb4AP2r5j3puUJEmSzCsDDstIOg3YBlhF0jTgS8BiALZ/BHwRWBk4oZhbzRjM6qkkSZKkHgMGd9t7DXB8f2D/IWtRkiRJMs+kcViSJEkXksE9SZKkC8ngniRJ0oVkcE+SJOlCMrgnSZJ0IRnckyRJupAM7kmSJF1IBvckSZIuJIN7kiRJF5LBPUmSpAvJ4J4kSdKFZHBPkiTpQjK4J0mSdCEZ3JMkSbqQDO5JkiRdSAb3JEmSLiSDe5IkSReSwT1JkqQLyeCeJEnShWRwT5Ik6UIyuCdJknQhGdyTJEm6kAzuSZIkXUgG9yRJki5kwOAu6WRJ/5B0cx/HJekHku6SNFXSmKFvZpIkSfJyGEzP/RRgp36O7wyMKrcDgBPnvVlJkiTJvDBgcLd9JfBEPw/ZFfi5g4nAKyS9eqgamCRJkrx8hmLM/TXAAy33p5V9L0HSAZImS5r86KOPDoF0kiRJ0htDEdzVyz739kDb422PtT12+PDhQyCdJEmS9MZQBPdpwOot90cADw7B6yZJkiRzyVAE9wnAPiVrZnPgadsPDcHrJkmSJHPJogM9QNJpwDbAKpKmAV8CFgOw/SPgfODtwF3A88C+tRqbJEmSDI4Bg7vtvQY4buC/hqxFSZIkyTyTK1STJEm6kAzuSZIkXUgG9yRJki4kg3uSJEkXksE9SZKkC8ngniRJ0oVkcE+SJOlCMrgnSZJ0IRnckyRJupABV6gmSTJ0jDzivHl6/r1H7zJELUm6ney5J0mSdCEZ3JMkSbqQDO5JkiRdSAb3JEmSLiSDe5IkSReSwT1JkqQLyeCeJEnShWRwT5Ik6UIyuCdJknQhGdyTJEm6kAzuSZIkXUgG9yRJki4kg3uSJEkXMqjgLmknSbdLukvSEb0cX0PSZZJukDRV0tuHvqlJkiTJYBkwuEsaBhwP7AyMBvaSNLrtYZ8HzrC9MbAncMJQNzRJkiQZPIPpuW8G3GX7btv/AU4Hdm17jIHly/YKwIND18QkSZLk5TKYYh2vAR5ouT8NeFPbY74MXCzpYGAZYPshaV2SJEkyVwym565e9rnt/l7AKbZHAG8HfiHpJa8t6QBJkyVNfvTRR19+a5MkSZJBMZjgPg1YveX+CF467PIR4AwA238BlgRWaX8h2+Ntj7U9dvjw4XPX4iRJkmRABhPcJwGjJK0paXFiwnRC22PuB7YDkLQeEdyza54kSdIQAwZ32zOAg4CLgNuIrJhbJB0paVx52KeAj0q6ETgN+LDt9qGbJEmSpEMMZkIV2+cD57ft+2LL9q3AlkPbtCRJkmRuyRWqSZIkXUgG9yRJki4kg3uSJEkXksE9SZKkC8ngniRJ0oVkcE+SJOlCMrgnSZJ0IRnckyRJupAM7kmSJF1IBvckSZIuJIN7kiRJF5LBPUmSpAvJ4J4kSdKFZHBPkiTpQjK4J0mSdCEZ3JMkSbqQDO5JkiRdSAb3JEmSLiSDe5IkSReSwT1JkqQLyeCeJEnShWRwT5Ik6UIyuCdJknQhgwruknaSdLukuyQd0cdj9pB0q6RbJP1qaJuZJEmSvBwWHegBkoYBxwNvA6YBkyRNsH1ry2NGAZ8FtrT9pKRX1mpwkiRJMjCD6blvBtxl+27b/wFOB3Zte8xHgeNtPwlg+x9D28wkSZLk5TCY4P4a4IGW+9PKvlZeD7xe0p8kTZS001A1MEmSJHn5DDgsA6iXfe7ldUYB2wAjgKskrW/7qTleSDoAOABgjTXWeNmNTZIkSQbHYHru04DVW+6PAB7s5THn2J5u+x7gdiLYz4Ht8bbH2h47fPjwuW1zkiRJMgCD6blPAkZJWhP4O7An8P62x/wO2As4RdIqxDDN3UPZ0CRJkpfLyCPOm+vn3nv0LkPYks4zYM/d9gzgIOAi4DbgDNu3SDpS0rjysIuAxyXdClwGHG778VqNTpIkSfpnMD13bJ8PnN+274st2wb+u9ySJEmShskVqkmSJF1IBvckSZIuJIN7kiRJF5LBPUmSpAvJ4J4kSdKFZHBPkiTpQjK4J0mSdCEZ3JMkSbqQDO5JkiRdSAb3JEmSLiSDe5IkSReSwT1JkqQLyeCeJEnShWRwT5Ik6UIyuCdJknQhGdyTJEm6kAzuSZIkXUgG9yRJki4kg3uSJEkXksE9SZKkC8ngniRJ0oVkcE+SJOlCMrgnSZJ0IYMK7pJ2knS7pLskHdHP43aXZEljh66JSZIkyctlwOAuaRhwPLAzMBrYS9LoXh63HPBJ4JqhbmSSJEny8hhMz30z4C7bd9v+D3A6sGsvjzsKOAZ4YQjblyRJkswFgwnurwEeaLk/reybhaSNgdVtnzuEbUuSJEnmksEEd/Wyz7MOSosA3wU+NeALSQdImixp8qOPPjr4ViZJkiQvi8EE92nA6i33RwAPttxfDlgfuFzSvcDmwITeJlVtj7c91vbY4cOHz32rkyRJkn4ZTHCfBIyStKakxYE9gQk9B20/bXsV2yNtjwQmAuNsT67S4iRJkmRABgzutmcABwEXAbcBZ9i+RdKRksbVbmCSJEny8ll0MA+yfT5wftu+L/bx2G3mvVlJkiTJvJArVJMkSbqQDO5JkiRdSAb3JEmSLiSDe5IkSReSwT1JkqQLGVS2TJJ0GyOPOG+un3vv0bsMYUuSpA7Zc0+SJOlCMrgnSZJ0IRnckyRJupAM7kmSJF1IBvckSZIuJIN7kiRJF5LBPUmSpAvJ4J4kSdKFZHBPkiTpQjK4J0mSdCEZ3JMkSbqQDO5JkiRdSAb3JEmSLiSDe5IkSReSwT1JkqQLyeCeJEnShWRwT5Ik6UIGFdwl7STpdkl3STqil+P/LelWSVMlXSLptUPf1CRJkmSwDBjcJQ0Djgd2BkYDe0ka3fawG4CxtjcAzgKOGeqGJkmSJINnMD33zYC7bN9t+z/A6cCurQ+wfZnt58vdicCIoW1mkiRJ8nIYTHB/DfBAy/1pZV9ffAS4YF4alSRJkswbiw7iMepln3t9oLQ3MBbYuo/jBwAHAKyxxhqDbGKSJEnychlMz30asHrL/RHAg+0PkrQ98DlgnO1/9/ZCtsfbHmt77PDhw+emvUmSJMkgGExwnwSMkrSmpMWBPYEJrQ+QtDHwYyKw/2Pom5kkSZK8HAYM7rZnAAcBFwG3AWfYvkXSkZLGlYd9C1gWOFPSFEkT+ni5JEmSpAMMZswd2+cD57ft+2LL9vZD3K4kSZJkHsgVqkmSJF1IBvckSZIuJIN7kiRJF5LBPUmSpAvJ4J4kSdKFZHBPkiTpQjK4J0mSdCEZ3JMkSbqQDO5JkiRdyKBWqCZJLUYecd5cP/feo3cZwpYkSXeRPfckSZIuJIN7kiRJF5LBPUmSpAvJ4J4kSdKFZHBPkiTpQjK4J0mSdCEZ3JMkSbqQDO5JkiRdSAb3JEmSLiSDe5IkSReS9gNJWgAkSReSPfckSZIuJIN7kiRJF5LBPUmSpAsZ1Ji7pJ2A7wPDgJNsH912fAng58AmwOPA+2zfO7RN7X5y7DtJkqFiwJ67pGHA8cDOwGhgL0mj2x72EeBJ22sD3wW+OdQNTZIkSQbPYIZlNgPusn237f8ApwO7tj1mV+BnZfssYDtJGrpmJkmSJC+HwQzLvAZ4oOX+NOBNfT3G9gxJTwMrA4/NbcOaGqLIoZEkSeaV+SGOyHb/D5DeC+xoe/9y/4PAZrYPbnnMLeUx08r9v5XHPN72WgcAB5S76wC3z2W7V2Eefjjmkaa08z0vHNoLm26T2gvqe36t7eEDPWgwPfdpwOot90cAD/bxmGmSFgVWAJ5ofyHb44Hxg9DsF0mTbY+d19dZkLTzPS8c2gubbpPa3f6eBzPmPgkYJWlNSYsDewIT2h4zAfhQ2d4duNQDXRIkSZIk1Riw517G0A8CLiJSIU+2fYukI4HJticA/wf8QtJdRI99z5qNTpIkSfpnUHnuts8Hzm/b98WW7ReA9w5t0/plnod2FkDtfM8Lh/bCptukdle/5wEnVJMkSZIFj7QfSJIk6UIyuCdJknQhGdyTJEm6kAUmuEtaVdIYSRtLWrUDeutKukDSeZLWknSKpKckXStpvdr6TVHWKfRsLytprKSVGmjHmpJ2k7Rup7WL/isb0v15E7ot+m/rgMZbJf1Q0jmSzpZ0tKS1K2t+UtLqAz+yLuU7NUbSK2przffBXdJGkiYClwPHAN8CrpA0UdKYitLjgROAU4FLgQuBFYGjgB9W1EXSfi3bIyRdUn5Y/izp9RV1Pww8IukOSTsDUwkTuBsl7VVLt2j/rmV7V+KcvxM4p7SrpvZKbbeVgWslrVjzh03ShLbb74Hdeu7X0h2A/6v54pKOBvYBJgLTgbuBvwFnltXwtTgKuEbSVZIOlDTgCs+hQNIJLdtvBm4Fvg3cJOntVcVtz9c3YArwpl72bw7cWFH3hpbtu9qOXV/5PV/fsn0G8DHih/jdwCUVdW8ilkWvCTwDrFX2rwpMrfyeW8/3n4E1y/YqNf/PRWMmcE/bbXr5e3fN/zPRedgG2Lr8fahsb11Rd0Ift98Dz1U+1ze1bC8K/KlsrwjcXPPzVb5DOxA/YI8SHbYPAcvV/B+3bF8GjCnbryPWCVU71wtCDdVlbF/TvtP2REnLVNQd1rL9nbZji1fUbef1tvco27+V9MV+Hz1vvGj7MeAxSc/a/huA7Uc6YPLZmpO7qO17ivZjkmZW1v4MsD1wuO2bACTdY3vNyrpjgUOAzxXtKZL+ZfuKyrpvAfYGnm3bL8IFtiYzJa1k+wlgNcr3zPaTlZ1kbXsmcDFwsaTFCBvzvYBjgU705Je3fX1pzN3FTr0aC0Jwv0DSeUQxkB53ytWJS7sLK+oeL2lZ28/abr20Whv4Y0VdgBGSfkB82YZLWsz29HJssYq690v6BrAc8FdJ3wZ+QwS+hyrqAmwo6RniPS8h6VW2Hy6WF1W/BLaPlXQ68F1JDwBfYs4fm1q6M4vmmeXvI3TmOzkReL63HxFJc2vmN1i+DtxQdNYFPlF0hwM3VtSd44ejfJ8mABMkLVVRd11JU4v+SEkrlh+yRaj7XV4wFjGV8d9dCWthEUZlExwrZ7sOSR9q2zWhfCBeBXzS9v9W0l0e+C8isP0Q2BHYF7gP+Krt2gG+tza9AljP9l86pPdOoic90varOqHZor0LsGWt/+/8QpnHeB0x3PlUhzRfb/uOTmi16b62bdeDtqdLWgXYyvZvqmkvCMG9CSR9Bzjb9p+absvCSPmhGUWMeT/ZYe2liPmGmzusuzawIXCb7Vs7pLkiMMP2PzuhN0Bb1rX91w7qHdh6Vd5tzPfZMv2h8IevxQeB70u6T9IxkjauqDUgkjre62jTr+qFIenU0ptB0o7ALUSmzpTKWRQvSZOz/a9OBHZJl7W85w8S/k07A7+WdHC/T5433dUk/VxRVOcx4BZJ90v6chmLboqLa72wpP9uu30KOLLnfkXd6yV9XtJatTT6YkEYc++PmhMw02yPlTSKcLk8tUyAnAacVvMST9I/iaGR1ve3dM9+28tX0u0r7U9A3bQt2LBM5kKMeb/F9r0l+F0CnFlR+yjgCEWRmdOAM20/WlGvh+Et7/mTwBa2H5e0NDEuflwl3VOBI23vI2k3YoL188BniXrJ1TpNZS6p10NAzdzvrxA/nrcw+3s1jJhfqsmKxPu6TNLDxOfr17bba2IMOTks0weSrrc9pm3fBsTs+nsdxcBraR9HFDw53PYjZV/17A1JLxLj660/Kj0/Mq+xXS1LSFHNawvbz0i6mhiPnNlzzPYbKmrfAGxCTBy/DxgHXEd8EX9Ta8ii6L7D9t8lXQbsbPuF0omYWus9S7rR9oYt96+zvUnZ/qvtagvHSgflU8C/ezn8bdurVNJdg8h6+xvwFdvPS7rb9utq6LXozoojkt5CxI/dgNuITmK1K+IFoudeLmneTWTJzADuJE7M0zVl23fYnkos7PlsRV1sHyxpE+A0xeKeH9KB7A1iQcl2tu9vP1CySGryFaJ3czzwJ2JRyznAttTNioLm0uQOK3pnEz3KSyVdSPSkf1pJE+BRSXsTC8XeA9wLUFIRaw/VTiLy2f/cfkDSl2uJls/07ooFcn+Q9N1aWv204SrgqjLk9jaiI1EtuM/3PXdJnyRWKl5BDA1MAZ4kgv2Bti+vpLus7fY84I5S0qUOIrzy17K9WmW9/wKutv2SlDRJB9uuNUzQozEK2B94PdHxmAb8zvZFlXVvsN3rnIqkpWz/q6L2CsD7mfM9n1NzYrH0Yo8FRhPfp8NtP6RYmbuN7bMraq8EvGD7+Voag2jD0kRn4k22t6qsdbrtRooXLQjB/SZgI9svln/K+ba3KR/Qc/r6Ug6hfmuOec++VVrGSqsj6dXAxt2a+tk0TaXJJUGnv08LCwtKtkzP8NESlAmQcplVbWZfYW40DXhQ0sWSRrYcrjar3wdLAkuqsomWpMUl7SNp+3L//QqDp/+qnUUhaVFJH1OYtU2VdGPZ/nhtbdt3SFqkXCn1nIcx/UwwDwmSXiXpREnHS1q5ZKtMlXRG+UGvpdvYuZa0s6R7JF2tMAG8hfB8mSZpu4q6O7Vsv0LSSeW9/0qVjQgVJoTbSVq2rzbVYEEI7icBkxSpeH+hmHYpVrQ9UVH3GGBH28OJcbE/SNq8HKu6Fl/NmWj9FNgFOETSL4jhoGuATYn/Q01+AWxEXC6/vbTjK0Te96k1hSW9i1iB+/dyvq8ihi2mKhY11eIUwkjqAcJ35F/AO4r+jyrqNnaugW8UzcOJld4fsb0WMQb9rYq6X2/ZPhZ4mPhOTQJ+XEu0DCufAxwM3Fw+X721aegZyHxmfrgBbwB2B9btoOaNvbThdmKsv7ZxWCMmWhRzMOJK6RFgWLkv6huH3d7PsTtqn2/gVcw2TFun7H8tFc2d2v7P97cdm9Kl57rVSOuBDr7n6/vSqax7E7Bs2R4JTAYOaf//17gtENkytm8hsgk6uYpvuoq/SU8bymXjuUDtBQlNmWgtovByWQZYmkjHfIIYDqu9uOVJxWKlsz07BXIR4uqh+grVnv+zpPtt31723dczVFOJ1tdu93GvqdvkuX5K0seA5Us7DiOcT7fnpUZmQ8krFYuVBCwvSS4RlrrnephLYoZj3cY2wFkKW4KqIwDz/bCMGlrFBxxBWN3OwvY0wo716Iq6UEy0FDnBGyk8ZVB9E63/A/5KZFB8jkhH/Alx6Xp6RV2IhWK7M9tP/k7i0nm3cqwqLUG81Ut/GHUdQM/pGYe1/fkW3bWBmhO8TZ7rDwFjCG+ZHcq+i4A9gI9W1P0JMV+3LPAz4iqY8t2aUlH3YUkb9dwpgf4dRf+NFXUXiGyZm22vX7YnATu5ZRWf7Q2abWHnUAdMtCStBmD7waK3PTFkcG0tzV7asDLx2exIBoWkTQmf8Rfa9o8E3my79jh0Y3T6XC9sSBpBePc83MuxLV3Ru2pBCO5NreK7nrC7Pc3F17xJJI2z3VR1no7k/Zde7E7MuVjt4p6hg04iaWXbj1fWeBMxvPiMwqzsCKJXeyvwdVdcpDc/neuWNn3R9pEd1LvU9raVNV7hDjlfvkR7AQju2xB+F2cDKxEf/p5VfBfZPraS7j1Fcw/ikrVznhDh9zHHLuIcHAjgijah/bTpfttrVHz9PYgMihuBtxITyYsQl64fcCmiUUn7aODYMqcxlhgDnknMM+zjSsUzShrghrZnlGyw54GzgO3K/vbPwVDpNnauB2hXtc+YwlN9jl3EwrGe+ZUqIwCSZhAlQk8j5jg6Fujn++AOva7i+zuxcrHmKr7GPCHKB+JC4B/MnnTZnfji2/Z+fT13HnX7cscT8DnbNeuJTgU2d3h+rAL80vaOCj+fH9n+fxW1b7L9xrJ9GfAZ25MU9Wp/ZXtsJd3bbK9XtufwMpI0xfZGfT97nnSbPNfP9HUIWMp2lSQPRU3aZ4CvEimnIlJO3wwxeV5J9ybCrmQv4krpaiLQn+OKK59hAZhQBbD9tO0TbR9m+2Bgj5qBvRf9q2wfSBQL+SawRWXJLYCliInM/WzvCzxme99agb3wdcLFbrm227LU/6yI+NIBPAe8Emb5+VRxwWxhMUk9QWUp25OK9h1EplAtbpa0b9m+sVw1UH5Upvf9tHmmyXP9FDDK9vJtt+WoWO3L9jjiSnw8cVV0LzDd9n21Anthuu1zbX8AGAH8khgNmCbpVxV1F4xUyF6oXtCTXrIVbL9I9KirGlmVXuPbiIUPl0r6HzpjHHY9cUV0XfsBSftX1j4fuFDSFUQ21JlFdyXq/7+PB84vwzMXSvoeMd+yHXUzKfYnagZ8nvBV/4vCoO2BcqwWTZ7rnxPrBx7p5VjVYGf7t5IuBo4qn+dO1EKedT5LT/0M4IwyGvGuqsILwrBMO+ryCiqtlOyV7wFjXd+edB3gCffiZS5pVRf74Yr6byfMrG60/YeybxFgMdt2B/zAAAAgAElEQVS9WcQOpfZbgY/TZloGnOw2b6EK2ssRqYGLEnUEqp7notnYuZ4fkLQhYTFdcyUwkj5da15wQO0FMbh3CoWXy2uAa1ozRSTtZLu2De1CicLn4zXElcqDnQh0TdKTX297ZlnHsD5wr+2a1ho92o2ca0lbAY/Yvl3Sm4HNiayh8zqhX9qwLPFDfndT2Sy1WSDG3JtADXpClImtnu3FFGW6Jkj6esnvr6U7tiwaO1XS6pL+IOlpSZNUucygpI0kTSQyC44hfEaukDRR0ph+nzzv2pK0h6T3lu3tJP1A0oGquEJVDXnaNHyuv0csAvyFpKOK/lLAYZKqectIOqFl+81Euum3gZvKVUwt3WEKk7ajJG3ZduzzfT1vSHBFb4MF+UaDnhDM6YPxbcJgamvgu8DPK+pey+wiFQ8Au5f92wF/qfyepxD+2u37N6ein07ROIHIRJpAGGedCexDrMr9fkXdpjxtmjzXPWXuliasDpYu+xcjinjU0m39Tl0GjCnbr6t8rk8i5hIOJap7fae3NtW4LagTqp2gMU+IttffDtjU9nRJVxK5ybVYzPYFAJK+afssANuXSKo9briM7Wvad9qeKGmZytpvsf1Ghd3tw8Crbf+nZDPcUFPYzXjaNHmubdua7ZHUMy48k86NJCxv+/rSmLsVCyJrsZlLDr2kHwInSPoN0YGqGkcyuPfNw5I2sj0FwhNC0juAk6nsCQGsIOndxId9CZcJvfKlqDlJ8oKkHQjDMEt6l+3fSdoaeLGiLsAFks4jsil6SvqtTvSga89vzAAoP6CTbP+n3J+hqCtbDUmLOFaFdtLTpslzfZ6kq4gaBScRmSMTiSvTKyvqrqvI7xcwUtKKtp/smUSuqDvr/2h7BnCApC8SNt7L9vmsISAnVPtATXpCSO31M4+w/YjC5OiXtqsUNSgZBMcQvajDgE8QRk9/Bw6o+Z6L/s7ArsQkn4iMlQmuXIFK0gVE0fNn2/a/quhvVkm3MU+bps510d6C6KtM1Oz6yPcDZ7mS/UG54m7loXJ1tgpRjL3Kqm9JpwKnui0Bo6Rinmi7XsGhDO69owY9IZL5gzJEsYztf3RQs7qnTRJIGtMzPNONZLZM3zwm6Y+SPqJwR2wUSe1+353W33fgR83T6y8iaV9J5yrKvl0n6fQy11EVRVk9tdx/q6RPET26aoFd0tGabWc9VtLdRMm5+8pQWC3dxs71AO2q6R80pu22CTBBUeqvWoaQpHGSlqz1+v1qZ8+9d9SgJ4TCB2OOXYTB06Uwayl1R1F947CfAvcRpdd2J7JHrgL+hzjnx1XUvhHYpozBHk4ME5xPjANPtv3ZSrpNedo0ea77MkMT4WszvJLuTGAi0LpAa/Oyz67kDinpX4TFwwVE/LjIsdK9Ohnc+0BzGoctRdRb3JP4wl9k+/01tYk83JOIbAIRH4w9AVzPpbDdOW/WIeD1tqv5rEia6hZnPkkTbW8uaQmiDNp6FbVbawZMJrJn/qXwm7ne9RwD/wqsXyZuJ9revOXYrMBfQbfJcz2d8FfpLfDs7vCYqaG7O7Fm5Zs98wqS7rG9Zg29Ft0bgG2JH9E9iUVqvyXMB6t8j3vIbJm+acwTAhgLHEJUQzrc9hRJ/6r9YSAqT+3IS0utibCFrcl0SWvZ/lu5TO7JWPl35QwhgGckrW/7ZsLjZUnCWGtR6g5dNuVp0+S5nkrYK9/cfkDS9rVEbZ8l6ULCV2Zf4FN0xq/Jtp8kKkH9pEzS7wEcLWmE7dVrCWdw75tf9rbTUUDhZzWFS8bAdyWdWf4+Qmf+V+cSC7deElgkXV5Z+3DgMkn/Jt7rnkV3eGlXTT4O/LIMz/wDmKww1dqAiquRbR8n6Wbm9LRZh/C0+WotXZo914cSw0C98e6awiUb6jBF2bufEY6ntZkjl71k3/0A+EEvGTxDK5zDMvM/ivz6/2f7f5tuS03KpObKbqDkmyK3fAfmNA67qFszppo81/MD5f0vZ7uvH5qh0tnG9uU1NfrUzuDeO+XLvj/hwXxha463pM/brtmz6q09K7kzZlJrAM/YfkqRbz0W+Gtvl9EVtNdldu61gQeJ3Ovbams3QQkw7yXe61nE2OyuRJHyH9XK+S7ajZxrSa8DPl/0jiYsNbYgiuAc7vBZr6G7SusPmaS9gc2Am4GfuAsDYaZC9s2PicnTx4lLqO+0HKtS/qwHtRgKSRot6Q5iqOBeRd3NWrpHAFcAExWLLC4kvGZ+rb6rNA2V9v8QXi4iPG4mle3TSrtqaq8r6QJJ50laS9Ipkp6SdK2kapOLxJj7HsAHgV8QwzOTga2IoFeFJs814ZM0CXiWyFT5K/EZu5BY/V2Li3s2yvfrg4TXy9uA7/T1pHlFYcB3uqSrJP2vwuKi59jvaukCaRzW140ovt2zvShRweU3RGWeThqHnUcUBYfoafy5ou4thEPfysA/geFl/zJUNHUqGncQ3jbt+xcH7qysfSWRDbUXkSK4JxHs3glcUlH3pvJ3MaITsXjL5+2mLj3XN7Rs39/Xscq61xOL03rOfc1z/QfiR3sj4DgiMWHl2u/Xdvbc+2EOTwjbBxAZDNU9IdpYzcXMy/a1RPCtxYuOzKCniGyRx4vucxU1e5gJrNbL/leXYzVZzvbvbZ9GlEU73cHvibKDtZjlaQPM4WlDXS+fJs/1TEmvV1gvLK3ZpQXXBmoaeC1VFixtQpgCPgezzn3Ncz3c9o9sT3GUCD0BuFJhu1B1KCizZfpmstqKctg+UtKDwImVtV9XFjIJGCFpadvPl2M1TY6uVzghLgNcAvyspI9tS+Td1+RQ4BJJdzLbzGoNYG3goMrarUGl/RK9poHXw5KWtf2s7Z16dpZ0uf9U1G3yXH8G+D3xI/Iu4LMKT6PlgY9W1H2I2f/bJyS92vZDklam/MhWYjFJS7r4B9k+VdLDwEXE96waOaE6H6KXLj2/zuFKuSqx0OP4SrqLMucE32bA+wlTp+Nr9+AVDn2bMaeZ1SRXXtEn6WOEIVu7cdjawEG2D62p30t7qnvaNHWu+2jLKsCTDWkPI5xXnx/wwXP3+ocRw6xXtO3fGDjG9ttq6EIG9z6RNA642G2OfU0h6ZU1v+zzCyXXegTRm7qnPeB2E4qyetNdvoSKOq5jgFt7huIq689X51rS21zquXZI7+vu4vTiDO59oCY9IaIKfTvXAxsT/7PqKZHtSLrA9s4VX380sbhjJDFEcAPwSiJ75xDH4rFa2u8GrrD9RAl43ybO9a3Ap2xPq6TblKdNY+d6gHZV8y+S9IP2XUTGzM8BbH+yku53gLNd2S67V+0M7r2jBj0hFCZH97XtHkFcOtv26yrp9uWOJ+Bc26+uoVu0JwIfchRN3gz4L9sfkvRRYEfbu1fUvtX26LL9ayJF70xge+ADtS6d1ZynTZPnut0Ub9YhYFvbVcahJU0jasZezOxVo8cCnwawXWXVuaRHie/ycODXRPyoWt1rlnYG995Ri3FYud/jCbEXUNUTQtKnicByuO2byr57XN/k6EWi99Zb+a/NbVfL1JF0o+0NW+63GrfNCr6VtG+3vU7Zvs72Ji3HptjeqJLun4kiKDeXieu9Si9+SaLnvn4l3SbP9ZPA3kSe+xyHgF/bXrWS7nLAUcQVyuG2/y7p7lodpRbdG2xvLGkU0Unck5jAP40I9HfU0s5smb5pzBPC9rGSTid8ZR4AvkRnTI5uAz5m+872A6UdNfmbpC8QWTq7UYyzyqKP2p/TyyUdCXyjbPeUF3wrUHOIohFPG5o91xOB53u7+pV0ey1R2/8EDi2pkKcqygx2IhXcRf9O4sflKEkbEJ3E84kMpSpkz70P1KAnRFs73km4Q460/arKWrsTCzpe8iXrCXgVtV8B/C8wmigCfrTtfypcONezPbGi9mLEOe6pYzqCmG/5PVHi8P6K2h33tGnyXM8PSBJwILCF7b0ra91ge+OaGn1qZ3Cf/1H4ya/lDvi7LOyUALeos9RdNSQtWhZqIWlZYF3g7iYSBWrTs46hCe1codoHatIT4qVsAuwgaYeaIpJWkvRFSfsr+JyiFNu3JNVcqYmkFRRl526T9Hi53Vb2VS9zKOlVkl5VMkUWkbSbpDdU1mzE06bJcy3pw8Ajku5QFOmeCnwTuFHSXhV192vZHiHpEklPSvqzovJVFXoCe2v8aGnHKrV0IYN7f5xMzK4fTCzLvkKxmg2grg+zdG3L9keBHxLe019SXWOnU4lVc5sAlwGvIr54/yIMn2pyBlEk5K22V7a9MlFa8Ekic6UaikVMfyEM0z5BeJq/A/iNpI9UlB5PLEc/lbC1uJCwOziK+J/XorFzTRTJWIcoCvNr4G22tyPcR6ukfhZaV95+hzgHKwPfouKKc0U93mnAg5IuVjit9nBx788aIlzRuGZBvhHlxlrv700Ya61Fi7FXJe1Wk6NJzGngVdPkaEr5K+Dv/Z2PCtq3z82xIdK+CVia+LI/C7yq7F+x5vtu+z/f1Xas2mes4XM9pWX7wbZjUyvqXt9bG9r/DxV0JwFvKNu7A3cSmWdVdW1ntkw/NOYJQQwLrEhcWcn2o6UNz0mq6YPRo7scsKykkbbvLVcsNT1WAO6T9BngZ7YfAVDYLXyY2f4ntZjuWH7+vKS/OTKjcKQl1pyUasrTpslzfb+kbxCfsb9K+jbhtro94f9SixGKhUwChktazGEaBnX9mha3fQvMKvV3G3FFeASVM+ByWKZvTgLm8E63/UfCe6X2xOYKhNf0ZGAlRY59z+RTbznoQ8U3CH/tSUTmyEmS/kCMi36voi7A+4ie8xVlLPRJYlhsJWJ9QU1mtoyJ7tKzU5FvXrWGavmfYvuEFt21gT9W1G3yXO9NlNmbBowjLHA/S+Sff7ii7uHM/k79L8XZtXy3+lpYNRRM7/n+ApRAvx2R3jyqom5myyxISFoaWNX2PRU1hhGfixmKlZIbEUM0NXtVjaKoPvWgSwZHy/7XEKmBNQNt0sUoin4/avvGtv0rEKZ0X6umncG9d9SgJ0RvSDqwtXfXgP66tv9aWWMtwl9ldcLM6k5iFV9HvU4kLU/0qu52VK6vpdOIp03Rni/OdVubxjvqJnRK7w7b1TJlmiaDex+oSU+Il5a0E3Hp+nUA29XKgvXTpmqmTuX1P0lUProCeDuxavJJIgAd6IoLyiSdChxq+zFJOxJDcrcTAf7TtqtkkKg5T5smz3VvpngQn/EbbY+opPtPYoy7dVhzaeB5wq9p+Uq61xNzCqfZ/lsNjT61M7j3jhr0hCgfxPOJ7JyeD+OhlHFv21+ppNvunDfrEGE0VeULULRvAjay/WIZfjrf9jZlyOQcV1zlJ+km228s238G3l8mklchyuxt2P8rzLVuU542TZ7rF4lOU2uQ7Qm6r7FdZSJZ0nHEXNbhLZPI97i+X9M9wNnEXMbDRPz4te0Ha+pCTqj2xyxPCNtH2X4D8Q9akgi8NXkD8UOyDPCtEsyftP2VWoG9sC8xWXxd220ydSsD9dCTvbUEkU2BY+l/zWwGiCyhnh+umURxEmw/Rl2vlcslHalYgXy5pHdB5EZT19MGmjvXdxM2x2u23F5XguwjtUQdJe6+TxQB/6SiWEknerZP2v50uer9FHE1eL2kyyRVHYLKVMi+eUlWiu2pROZIzcUWPV+y3SXtCvxB0ndr6rUwiSiE/ef2A5K+XFn7JGCSwo52K2LxFGUsuvay9K8Al0k6HvgTcKakcwjL5wv7fea8cRDhadPj5XOYpB5Pmw9W1G3yXH+PWD/Qm1/PMTWFbV9XJjgPIoaklqyp14v+VcBVkg4G3kZkLY2vpZfDMn2gBj0h2tqxNBF83mR7q8paKwEvuFLJsUHovwFYj/iBqTp524v2KGB/5jTw+p3tizqk31FPmybP9fyApFcDG9uuehUu6XTbe9bU6FM7g3v/tC126Nm3Srlk73o6+V4lidl1PQ08CFzrLv6Q9uRA23649JzfQqwSvaWybiPnWlFacE8i9fSPkt4P/D/Cbnp8+3etYjvWpGQmdeuPW46594Ea9ISQtFPL9isknSRpqqRflZWEtXR3lnSPpKslbSzpFuAaSdMkbVdLt2jvQKTjfZnI4NiFuGK5U/UN05aW9BlJh0taUtKHJE2QdEzPIqNKuo142jR5roGfFr1DJP2CWBR4DbApMVxUBbWY/ZXhzkuJjKFzFGZm1VAYxG3X/llq/Z5X4eV4FSxMNxr0hGBOH4yTgK8SZmWHEUMFtXSnEJfqWwCPt7zf9ajvp3Mb4Vnfvn9N4LbK2mcQOeYnEAUsfkiMRX8L+EVF3aY8bZo811PL30WJCdRh5b6o6y3T6uPzZ2DNsr0KkYJZS/eTxJzK74B7gV1bjlX9TuWEat805gnRxljPTon7rqQPVdSaafs2AEnPuxRtsH1byS6oSc84dzt/p34Gx+tt71GGKh4CtrdtSVcRxSxq0ZSnTZPnepEyNLMM8cO2AjGJu0Rl7dbzuajLKm/H2oaZFXU/Cmxi+9ly9X+WwrPp+9S1Esng3g/TFf7ePV+4W8rQxLmEM2RNXqlYyCRgeUly+amn7lDaU2WoYHngSUmHEb3a7Xlpzcuh5mQig+N0ZptXrU6Mz/5fZW0gVrJIOr/nXJf7NYPszJY5nU562jR5rv+P8C8aRmQKnSnpbmBz4PSKuhtKeob4Ti3R890uPzTDBnjuvDDMJTHDsXZiGyLAv5bKwT0nVPtATXpCSF9q23WC7UfL5NsxtveppLs68Hki1/srRJ3HjxCLTj7d06uvhaTRhJnUa4gP/jRggu1bK+ueRKxQfbZt/1qEc+KbK+k25mnT1Lku2qsB2H5QURxke+B+29f2/8wqbXkFca7/Uun1LwX+2/aUln2LEj+wH7Bd7Yclg3uS9EPbVVNtrY542syvdDr9WNI42zUdIZE0ApjRMwLQdmxLV/SuymyZPpB0vaTPl95b45QeQJP6X6z8+ssqVmveIulpSY9Kmlg7k6For1GGQlCwr6TjSgZLvZ6VdKpKqTWFp80txIKiKZLeW1G3sXM9ANWuGhRlE1tv7wHG99yvpQs821tgB6gZ2CF77n2iBj0hJE1t30UsrrkdwPYGtdvQS5tqG4edA/yW8DHfg5hwO50YJvq77f+tqH0zsJnt5yV9k5hT+R2xQhXb+/X3/HnQbcrTpslz3W6KN+sQ8DnbfRmLzavuDGK18T+YPda9O3AWMb1S6388g/DKP41wmX2qhk6v2hnce0fS9bbHlO23EOPPuxFpZKfZrrdsWJpAFDT4KlG/VMBVwJsBbN9XSfeZvg4BS9muNgEv6cbWYCZpku1NS5bOrbbXrajd6s54HbCp7Zm9tWuIdW8BtrD9jKSrga1adG9x+BnV0G3yXL9ApJj2VlHsMNtVCnRL2hQ4mgjmPyqT5fe4vnHYTYRdyV7ATsDVRKA/x/a/amrnsMwgsH2V7QOJyadvEnngNfXGEVcN44ENbd9LpM3dVyuwF54CRtlevu22HHVLoAE8J+nNAJLeSfE4KcGualYB8ICkbcv2vUTmCJpdEL0WPZ42+zHb02YfSadQ19OmyXN9PbFW4yvtN+CftURtTyL8XBYHLpW0GZ1JaZ5u+1zbHwBGAL8krpamSfpVVeWXmxi/sNyA0+eDNixD1NacAEzrgN5XieGJ3o59s7L2BsC1hBvi1cA6Zf9w4JOVtVcHLgOuJEy7niRWMN4AbFdZexTRYfht0T4R2LGLz/U6lILvvRxbtaZ2i85qRIrv3R3Q6nXBI5Hf/6Ga2jksswAgaUPi8v1HTbelm5G0HnMah01yGSZJkrlB0qdtH9uIdgb3vpG0LjEUc41bUrQk7WS75mVzezuWJYLO3a48ISNpK+AR27eXS/fNiSXp59XULdo7Au9iTjOrczp5rlvaspLtqva3CsfPg4j3ehxhAfseYpHPka6YFtjUuZY0lhhz/zsxFn0yYWB2B3CAK1U7k7SBw7IbRTH0/ym6NwNfdUNOqDXJ4N4HilJk/0VMoG4EHGL7nHJs1mRrJe0THGP8lAD7K+BvwNrAx1zJplTS94gP/KLARUSV9guArYnLy8Nr6LZovx74ObOXxo8A9gHutH1IRe0tCQ+fmcB+xPDUWsRy+D1cb4HLGcQK0aWI4YrbiOGCdxI+M1U83Rs+19cCXwJeQfi3H+aw99iOCLJV5rPaEiS+Tfj5/JT4gVvZ9RYGDiOspEcAF7ol/VHS521/tYYukGPufd0IU6dly/ZIohrRIe5nHG0ItVuNwy4DxpTt1wGTK+r2lPVbmhh3XrrsX4zw/a75nu/oY7+IgFNT+1rgjcRE+WPAm8v+McCfKupOaXmPDzO7s1XbRKvJc91q4HV/X8cq604BFuvQuT6J6JwdSlQ1+07LsarGYZkt0zdzeEIA2wA7S/oO9TMKWlne9vWlHXdT1wfDjk9dzzhzz2XdTOpnVr1QMhja2RR4obL2YrZvcvTQH7V9NUA570tV1qac8zk8baibydHkuX5B0g5lkZY1u7Tg1sCLFXVXkPTusnhpCRff+A6c681sv9/294A3ActK+o2kJUjjsMZ4WNJGLp4QDle3dxBjhG+srL1uWcgkYKSkFR1OgYtQ1znvPIUT4pJEj+MMRSm2rYlMkpp8GDhR0nLMHipYncj3/3Bl7dYfrvYSilUKNhcmqyy5d8siGsWq6GppgTR7rj9ODMfMBHYEPlFSP/8O1KwpegXhpQPhn7+q7UcUfk01i9HM+vw4PIQOUKz2vhSoVisAcsy9T9SgJ4TCMa6Vh2z/p6xc3Mr2bypqb0F0aCaWIPNuot7lWe5A5kj5ss0ys+rt/FfQHAf80W2TauX9v8d21dqefbSpuqdNE+d6YUPSqcCpbpuolrQ/cKLtap21DO59IOkV7uBS4YGQNKZneKabKdkUqxMrGO90l5ZAg1mukP+w/YIkEb3mMYTHyk/c5hZZQX++OteS9rX90w7q/dyVJlLnBzK490GjnhBSeyaOgHOILAo1EeRbfVAqvf7WRDWkp4BNiBWbKwLTgQ/afqCfp8+r9kHEorXHJK1NDL1tQHj5fMT2zZV0m/K0aexcD9Cuav5FxdJjjl3AW4nhERyrwmvojgMutl17LuOl2hnce6dJTwhFZZiJwL9bdm9e9tn2tr0+cd51+3LHE+HHMbyGbtG+AdjB4Vu/JpFV8G5JbwMOt12ttmerj4uk84CTbP9WUVjha7a3rKTblKdNk+e63RRv1iGiItYSlXSvJ66ITiImUEV8n/cEsH1FJd1/Ac8RKcWnARfZrjlxPIucUO2b6bbPBc6VtBTRa94TOF7SRbbfX1F7D+Bg4FsuOe3F5OitFTUBfk14X/T2i79kZe1hth8t2/cTNWOx/YeSl12T1u/BK23/tmhfXiYda/GApG1tX8psT5v7OuBp0+S5XpWYSG33qxdR27QWY4FDiOpPh9ueIulftYJ6C38lrsR2Bz4F/FTSbwnzwaraGdz7ZlaaUumpn0Fkj6xALHyohmNRx4XAUZL2JT4UnbjEmgoc29swhKIyVU0mS/o/okD1rsSQWM8qzprpnxBlz04BjgR+K+lQ4DfEIq77K+ruD/xc0pcJn5cppVe9ItCXNe5Q0OS5PpdYPzKl/YCky2uJliui70o6s/x9hM7EPzsKr/wE+EmZxN4DOFrSCNur1xLOYZk+UIOeEG3t2Aj4LvAG26+srPUW4D7bLwloksbanlxRezGimPBooij1ybZfLFdNr3RdN0wUhSo+QYx7L0GsHP0dYZj2dGXtjnraNH2u5wck7QJs6Yre9UXnBtsb93HstTXPdQb3BYCSSbGc7b781rsKSSsxu8eTJAsskraxfXkT2rlCdS6QVHOxxUtw8EzRfkcntXuorasodXe6pH8A1wCTJP2j7BtZU7vob6Yo6ICk0ZL+W9Lba+v2055qxWAG0P1yE7pF+9xu020qsEMG97mlk/YD7Wzapbq/JjzNX217lO21gVcTQyOn1xSW9CXgB8SqzW8APyRWDx4h6XM1tfvhxw3pXteQLsRQ0UKjW/sHPIdlkvkCSXfaHvVyjw2R9k2E8+cShIHXCEfpu6UIu+eO16xNuh9Jm9iu9mOaPfd+kLSupO0Ufuqt+3eqrLuGpCXLtiTtK+k4SZ+QVHWGv7zn/5H0A0nfL9vr1dQsXCfpBElvkrRaub1J0glERaSazLD9YrEf+FvPEFjJkqo5sTlW0mWSTpW0uqQ/SHpa0iRJvU7CVWzLHZ3U66MNF1R87eslfV5hKTFfUDOwQwb3PlH4uZ9D5JvfLGnXlsNfryx/PrP/N0cDuxDj0JsSdVWrIOl/iCEQETa4k8r2aZKOqKVb2IewWf4K4SV/cdm+Gajia97Cf0oaIMSKTQBK2mtNP50TCBOt84gc7x/bXgE4ohyrgqR/Snqm3P4p6Z/AWj37a+kW7TF93DYhrp5qsSLhIX+ZpGslHSZptYp6QPj3SDpR0vGSVpb0ZUk3STpD0qurauewTO+US/UtihvkSKJq+i9sf7+/9KYh0m5q5eIdRMrl9Lb9iwO31BwaaRJJS9j+dy/7VyHmAG6qpDvrc6S2pfc1P2OSjiNqeB5u+5Gy7x7ba9bQa9N+kXBo7G3eanPbVSyWNWexjrcQK893IwqknGa7SqdJsV7lPKIe8vuJRYKnEesLtre9az9PnydyEVPfzOHnrliKfpbCsbH2hGpTKxdnEsWD23NvX03dHiwAkt5KlJmbZWZFWAHcVVO3t8Be9j9GXTvYFyTtQARaS3qX7d+psre57YNLT/k0Sb8jJpA71cu7jagmdmf7AUk1PW1aFyVeBVwl6WDgbUR5w1pXxKvaPg5A0oG2v1n2HyfpI5U0gQzu/dGkn3tTKxcPBS6RdCexiAdgDaK830EVdZF0NLE0/RLgVcA9RGnBMyV93faZNfX7ade5tmulgfbnbV41g8P2dYpVxwcRPena9hI9fJm+h8pbOqUAAAVZSURBVIMPrqh7e/uO4vFyYbnVovW9/ryfY0NODsv0gRr0c2/R6ejKxaK5CFFHdZbPd9GtanakFtfJMml8he0tJa0IXGV7/Zr6/bTr1bYfqvj66xFXS40VYS9jvzfbrn1liKQ3EQXXe7KRPgtsTJh6fb3WauAyh/Zbd9jxUtKRwDFuK3aucB892vbu1bQzuA8eSSvZfmJh0+4Ekm4E3mr7CYXP+Rm2Ny/HZrk2dhMl4BxImEt1rAi7Xmp/C2FuVdX+tmjfAmxoe4Yiz/t5Yj5ru7K/L2fSedV9mnBn/Bsx5n1mi3laVTS76E3rcONptW0tMlumDyR9vmV7dJlsvE7SvaX3UVN7S0m3SbqlpAP+gTB7ekBRKamW7gaSJhad8aXX3HPs2lq6ha8DN0i6mLBXPqroDif8T6ohaXlJ35D0C0nvbztWLWuFGHoZa/tdRI3eL0g6pEe6ou4IoqTedwhf9+8QZf2+XW41WcSzi5CMtX2o7attf4UoAF+Lu4n3fRSREXWrpAslfUgVnT/LD/iJxLDXpkRN3tWBv5R5vHq4YvXtBflGS2VyYrZ757K9GfDnytrXEuP6WxATem8u+8cAf6qoezXhXf8K4NPALcBa5Vi1yvQt+isR1qyv6PD/+mwi5fRdwIRyf4n2z0EF3Vvb7i9LjP9+B5hSUXcR4DDgD8BGZd/dHTrXZwL7lu2fEgEeYvhxUkXd69vuL0bUVD2NKIpeS/cmIjkDYGng8rK9Ru3vVE6oDo7VbF8AYPvaMlZYk8Vc0u8kPWr76qJ9fWXtZT17nPfYkoZ5oaQP0oFsCsewUxNDT2vZfk/Z/p3CcuBSRRWdmjQyae/m7G8hkgW+X66MHyN6sA8QE/j7V9Sd40rIke47AZjQge/zokT20xLAckX/foU7Z1XRpHdeV8YmBYyQtLRnF1Cu+k9hzuGyz7YdW5x6SNIKLmOBti+T9B6iJ7tSRd2BGlVt/LmwhKRFStDD9tckTQOupG6F+n2IMdhZOIYs9pFU3VvG9jTgvQr72444jpbP1ofLUMjrKMkCLvn2FXlfP22qWVntJMIEbyKwFfBNmDXcWLUjkxOqfVByjVu5jviiG9jd9vEVtccBf2z5MUFh8r8M8B7bx1TSfT9xeT6xTXdx4Au2mzJ2qoqkY4g6l39s278TcJy7dPFW0hkkvQFYj8hI6lgR8gzuL4MO9CDnO+2G33PjGUKS9rX90ybbkCRzQ2bLvDyatPptSrsjuk1lCA2CrzSonSRzTY65vzx+shBqd0r3u0RtyWWJ7KR32b5a0hjgOGDLWsKSpvZ1iFg1myQLHDksk8wXaE4Trdtsr9dyrOrQUMkW2RFoL+snIu21untgkgw12XNP5heayhACOJdIA53SfkDS5ZW1k6QK2XNP5guayhBKkm4lg3sy39Jkpk6SLOhktkwyP9NkdlKSLNBkcE/mZ5rMTkqSBZoclkmSJOlCsueeJEnShWRwT5Ik6UIyuCcLLZJGSrq5l/0nSRrdRJuSZKjIRUxJ0obtmr7iSdIRsueeLOwsKulnkqZKOkvS0pIulzQWQNKzkr4m6cZSgjC9ZpIFggzuycLOOsB42xsQBSsObDu+DDDR9oZE8Y6u9LRPuo8M7snCzgO2/1S2TwXe3Hb8P4T3DETBlpEdaleSzBMZ3JOFnfaFHu33p3v2YpAXyXmqZAEhg3uysLNGSzGQvYCrm2xMkgwVGdyThZ3bgA+Vgh0rASc23J4kGRLSfiBJkqQLyZ57kiRJF5LBPUmSpAvJ4J4kSdKFZHBPkiTpQjK4J0mSdCEZ3JMkSbqQDO5JkiRdSAb3JEmSLuT/A80p00LkGLtcAAAAAElFTkSuQmCC\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "temp_hist = temp.select('mean_temp').rdd.flatMap(lambda x: x).histogram(11)\n",
    "# exercise for the reader: could we use expode() instead of rdd.flatMap() ?\n",
    "\n",
    "# Loading the Computed Histogram into a Pandas Dataframe for plotting\n",
    "plot_hist(temp_hist)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAXcAAAF6CAYAAADiXhggAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADl0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uIDMuMC4wLCBodHRwOi8vbWF0cGxvdGxpYi5vcmcvqOYd8AAAIABJREFUeJzsnWm4XFW1td+REEPfBxAChl7wAgKhE0UEpBGlExG9Iq149YLCpyACinARQVC5gsCNgohiUBoB6QSkV2kSCG1opA8gfaMgSsj4fsxVSVE5JwmhVlVOZb7PU8/ZtXdVjVV1quZee625xpRtkiRJkt5iULcbkCRJkrSfDO5JkiQ9SAb3JEmSHiSDe5IkSQ+SwT1JkqQHyeCeJEnSg3Q1uEs6TdIzku6agce+R9IfJd0h6RpJwzvRxiRJkoFIt3vupwNbzuBjjwPOsL06cATwvVqNSpIkGeh0Nbjbvg54oXmfpOUlXSZprKTrJb23HFoV+GPZvhrYtoNNTZIkGVB0u+feF6OAfW2vDXwdOKnsvx34ZNneHphP0iJdaF+SJMkszxzdbkAzkuYFPgCcLamxe2j5+3XgREm7AdcBTwATO93GJEmSgcAsFdyJK4mXbL+/9YDtJ4EdYPJJ4JO2X+5w+5IkSQYEs9SwjO1XgIclfQpAwRple1FJjfZ+EzitS81MkiSZ5el2KuRo4C/AypImSNoT+E9gT0m3A3czZeJ0Y+A+SfcDiwPf7UKTkyRJBgRKy98kSZLeY5YalkmSJEnaQ9cmVBdddFGPGDGiW/JJkiQDkrFjxz5ne9j0Hte14D5ixAjGjBnTLfkkSZIBiaRHZ+Rx0x2WkbS0pKsljZd0t6Sv9vGYjSW9LGlcuX17ZhqdJEmStIcZ6blPBL5m+1ZJ8wFjJV1h+56Wx11v++Ptb2KSJEnydpluz932U7ZvLdt/B8YDS9VuWJIkSTLzvK0xd0kjgDWBm/o4vEHJTX8S+Lrtu/t4/t7A3gDLLLPM221rkiSzKG+88QYTJkzg9ddf73ZTeoY555yT4cOHM2TIkJl6/gwH97Lk/1xgv7KStJlbgffY/oekjwHnAyu2vobtUYQxGCNHjswE+yTpESZMmMB8883HiBEjaPKFSmYS2zz//PNMmDCBZZdddqZeY4by3CUNIQL7mbbP66Mhr9j+R9m+BBgiadGZalGSJAOO119/nUUWWSQDe5uQxCKLLPKOroRmJFtGwKnAeNs/7OcxS5THIWnd8rrPz3SrkiQZcGRgby/v9POckWGZDYFdgDsljSv7DgaWAbB9CrAj8CVJE4F/Ajs7fQ2SJEm6xnSDu+0bgGmeQmyfCJzYrkYlSTKwGXHQxW19vUeO3nq6j/nxj3/MySefzFprrcWZZ57ZVv2ByKzm5z5b805+EDPy5U+SXuakk07i0ksvfcsE5MSJE5ljjtkzzKVxWJIkA57/+q//4qGHHmKbbbZhgQUWYO+992bzzTfn85//PG+++SYHHHAA66yzDquvvjr/93//B0RGyj777MOqq67K1ltvzcc+9jHOOeccIOxRnnvuOQDGjBnDxhtvDMCrr77KHnvswTrrrMOaa67JBRdcAMDpp5/ODjvswJZbbsmKK67IgQceOLltl112GWuttRZrrLEGm266KZMmTWLFFVfk2WefBWDSpEmssMIKk/Xaxex5SkuSpKc45ZRTuOyyy7j66qs58cQT+f3vf88NN9zAXHPNxahRo1hggQW45ZZb+Ne//sWGG27I5ptvzm233cZ9993HnXfeydNPP82qq67KHnvsMU2d7373u2yyySacdtppvPTSS6y77rpsttlmAIwbN47bbruNoUOHsvLKK7Pvvvsy55xz8oUvfIHrrruOZZddlhdeeIFBgwbxuc99jjPPPJP99tuPK6+8kjXWWINFF21vgmEG9yRJeo5tttmGueaaC4DLL7+cO+64Y3Kv/OWXX+aBBx7guuuu4zOf+QyDBw9mySWXZJNNNpnu615++eVceOGFHHfccUCkgD722GMAbLrppiywwAIArLrqqjz66KO8+OKLbLTRRpOHihZeeGEA9thjD7bddlv2228/TjvtNHbffff2fgBkcE+SpAeZZ555Jm/b5oQTTmCLLbZ4y2MuueSSftMN55hjDiZNmgTwllxz25x77rmsvPLKb3n8TTfdxNChQyffHzx4MBMnTsR2nxpLL700iy++OFdddRU33XRTlQngHHNPkqSn2WKLLTj55JN54403ALj//vt59dVX2WijjTjrrLN48803eeqpp7j66qsnP2fEiBGMHTsWgHPPPfctr3XCCSfQyPS+7bbbpqm9wQYbcO211/Lwww8D8MILL0w+ttdee/G5z32OnXbaicGDB7fnzTaR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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "temp_hist = temp.select('lon').rdd.flatMap(lambda x: x).histogram(11)\n",
    "\n",
    "# Loading the Computed Histogram into a Pandas Dataframe for plotting\n",
    "plot_hist(temp_hist)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAXcAAAF6CAYAAADiXhggAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADl0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uIDMuMC4wLCBodHRwOi8vbWF0cGxvdGxpYi5vcmcvqOYd8AAAIABJREFUeJzsnXe4XFXV/z9fkpBQA4RQJGDoRYpgQHixIEhVAQEpijQBG/WnKFZsKPjaqW8URBSDNCFKb1JUICGEXgXB0EvoooR8f3+sfXMnk3uTS3L3TDKsz/PMc8+cc+757pk5Z5191l57LdkmSZIk6Szma3cDkiRJkv4njXuSJEkHksY9SZKkA0njniRJ0oGkcU+SJOlA0rgnSZJ0IG017pJOlfSUpDv6sO/bJV0p6TZJf5E0ohVtTJIkmRdpd8/9NGCbPu77I+B02+sC3wF+UKtRSZIk8zptNe62rwWea1wnaWVJl0i6WdJ1ktYom9YCrizLVwM7tLCpSZIk8xTt7rn3xGjgYNvvAr4InFjW3wrsXJY/CiwiaVgb2pckSTLXM7DdDWhE0sLA/wBnS+paPbj8/SJwvKR9gGuBR4EprW5jkiTJvMBcZdyJJ4nnbb+zeYPtx4CdYNpNYGfbL7S4fUmSJPMEc5VbxvaLwEOSPgagYL2yvKSkrvZ+BTi1Tc1MkiSZ62l3KOQY4O/A6pImSfoU8AngU5JuBe6ke+B0M+BeSfcBSwNHt6HJSZIk8wTKlL9JkiSdx1zllkmSJEn6hzTuSZIkHUjbomWWXHJJjxw5sl3ySZIk8yQ333zzM7aHz2q/thn3kSNHMn78+HbJJ0mSzJNIergv+6VbJkmSpANJ454kSdKBpHFPkiTpQOa29ANJksyDvP7660yaNInXXnut3U3pGIYMGcKIESMYNGjQbP1/GvckSeaYSZMmscgiizBy5Egakv4ls4ltnn32WSZNmsSKK644W8dIt0ySJHPMa6+9xrBhw9Kw9xOSGDZs2Bw9CaVxT5KkX0jD3r/M6feZxj1Jko7gF7/4BWuuuSaf+MQn2t2UuYL0uSfJW4SRR1442//7z2M+1DKt2dU/8cQTufjii6fzUU+ZMoWBA9+aZi577kmSzPN85jOf4cEHH2T77bdn6NChHHjggWy11VbstddevPHGGxxxxBFsuOGGrLvuuvzf//0fEIOWBx10EGuttRYf+tCH2G677TjnnHOAmEH/zDPPADB+/Hg222wzAF555RX2228/NtxwQ9Zff30uuOACAE477TR22mknttlmG1ZddVW+9KUvTWvbJZdcwgYbbMB6663HFltswdSpU1l11VV5+umnAZg6dSqrrLLKNL3+Ypa3NElDiLJ2g8v+59g+qmmfwcDpwLuAZ4HdbP+zX1uaJEnSCyeffDKXXHIJV199Nccffzx/+tOfuP7661lggQUYPXo0Q4cOZdy4cfznP/9h0003ZauttuKWW27h3nvv5fbbb+fJJ59krbXWYr/99pupztFHH83mm2/OqaeeyvPPP89GG23EBz/4QQAmTpzILbfcwuDBg1l99dU5+OCDGTJkCAcccADXXnstK664Is899xzzzTcfe+65J2eccQaHHXYYV1xxBeuttx5LLrlkv34nfXle+Q+wue2XJQ0Crpd0se0bGvb5FDDZ9iqSdgeOBXbr15YmSZL0ke23354FFlgAgMsuu4zbbrttWq/8hRde4P777+faa69ljz32YMCAAbztbW9j8803n+VxL7vsMsaOHcuPfvQjIKKEHnnkEQC22GILhg4dCsBaa63Fww8/zOTJk3nf+943zVW0xBJLALDffvuxww47cNhhh3Hqqaey77779u8XQB+Mu6Oax8vl7aDyaq7wsQPwrbJ8DlHIWs5KIEmStIGFFlpo2rJtjjvuOLbeeuvp9rnooot6jUgZOHAgU6dOBZguHNE25557Lquvvvp0+994440MHjx42vsBAwYwZcoUbPeosfzyy7P00ktz1VVXceONN3LGGWe8+Q85C/rkc5c0QNJE4Cngcts3Nu2yHPAvANtTgBeAYT0c50BJ4yWN7/I3JUmS1GTrrbfmpJNO4vXXXwfgvvvu45VXXuF973sfZ555Jm+88QaPP/44V1999bT/GTlyJDfffDMA55577nTHOu644+jqt95yyy0z1d5kk0245ppreOihhwB47rnnpm3bf//92XPPPdl1110ZMGBA/3zYBvpk3G2/YfudwAhgI0lrN+3S0+1vhl677dG2R9keNXz4LNMRJ0mSzDH7778/a621FhtssAFrr702n/70p5kyZQof/ehHWXXVVVlnnXX47Gc/y/vf//5p/3PUUUdx6KGH8t73vnc6w/uNb3yD119/nXXXXZe1116b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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "temp_hist = temp.select('lat').rdd.flatMap(lambda x: x).histogram(11)\n",
    "\n",
    "# Loading the Computed Histogram into a Pandas Dataframe for plotting\n",
    "plot_hist(temp_hist)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "metadata": {},
   "outputs": [],
   "source": [
    "# let's use a struct to build a composite key\n",
    "temp = temp.withColumn('time-lat', F.struct('time','lat'))\n",
    "daily_average_at_latitude = temp.select('time-lat','mean_temp').groupBy(\"time-lat\").agg(F.avg('mean_temp'))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "If you’re used to RDDs you might be concerned by groupBy, but it is now a safe operation on thanks to the Spark SQL DataFrames optimizer, which automatically pipelines our reductions, avoiding giant shuffles and mega records. (HP Spark, pg. 43)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 77,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "root\n",
      " |-- time-lat: struct (nullable = false)\n",
      " |    |-- time: timestamp (nullable = true)\n",
      " |    |-- lat: double (nullable = true)\n",
      " |-- avg(mean_temp): double (nullable = true)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "daily_average_at_latitude.printSchema()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 78,
   "metadata": {},
   "outputs": [],
   "source": [
    "# this function is here to make it easier to reason with the column names, flattens structs\n",
    "def flatten_df(nested_df):\n",
    "    flat_cols = [c[0] for c in nested_df.dtypes if c[1][:6] != 'struct']\n",
    "    nested_cols = [c[0] for c in nested_df.dtypes if c[1][:6] == 'struct']\n",
    "\n",
    "    flat_df = nested_df.select(flat_cols +\n",
    "                               [F.col(nc+'.'+c).alias(nc+'_'+c)\n",
    "                                for nc in nested_cols\n",
    "                                for c in nested_df.select(nc+'.*').columns])\n",
    "    return flat_df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "metadata": {},
   "outputs": [],
   "source": [
    "daily_average_at_latitude = flatten_df(daily_average_at_latitude)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 84,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "root\n",
      " |-- avg(mean_temp): double (nullable = true)\n",
      " |-- time-lat_time: timestamp (nullable = true)\n",
      " |-- time-lat_lat: double (nullable = true)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "daily_average_at_latitude.printSchema()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Now let's get the average on each latitude\n",
    "daily_average_at_latitude = daily_average_at_latitude.withColumn('time-rounded-lat', F.struct('time-lat_time',F.round(daily_average_at_latitude['time-lat_lat'],0)))\n",
    "average_by_lat = daily_average_at_latitude.groupby('time-rounded-lat').agg(F.avg('avg(mean_temp)'))\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "root\n",
      " |-- time-rounded-lat: struct (nullable = false)\n",
      " |    |-- time-lat_time: timestamp (nullable = true)\n",
      " |    |-- col2: double (nullable = true)\n",
      " |-- avg(avg(mean_temp)): double (nullable = true)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# we used the struct in order to do a simple groupby that we can flatten again to get information\n",
    "average_by_lat.printSchema()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 89,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "root\n",
      " |-- temp: double (nullable = true)\n",
      " |-- time: timestamp (nullable = true)\n",
      " |-- rounded-lat: double (nullable = true)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# the names weren't very descriptive, let's rework that\n",
    "average_by_lat = flatten_df(average_by_lat)\n",
    "average_by_lat = average_by_lat.withColumnRenamed('time-rounded-lat_col2', 'rounded-lat')\n",
    "average_by_lat = average_by_lat.withColumnRenamed('time-rounded-lat_time-lat_time', 'time')\n",
    "average_by_lat = average_by_lat.withColumnRenamed('avg(avg(mean_temp))', 'temp')\n",
    "average_by_lat.printSchema()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 92,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "== Physical Plan ==\n",
      "*(10) HashAggregate(keys=[time-rounded-lat#982], functions=[avg(avg(mean_temp)#957)])\n",
      "+- Exchange hashpartitioning(time-rounded-lat#982, 200)\n",
      "   +- *(9) HashAggregate(keys=[time-rounded-lat#982], functions=[partial_avg(avg(mean_temp)#957)])\n",
      "      +- *(9) HashAggregate(keys=[time-lat#759], functions=[avg(mean_temp#500)])\n",
      "         +- Exchange hashpartitioning(time-lat#759, 200)\n",
      "            +- *(8) HashAggregate(keys=[time-lat#759], functions=[partial_avg(mean_temp#500)])\n",
      "               +- *(8) Project [time-lat#759, mean_temp#500]\n",
      "                  +- *(8) SortMergeJoin [time#244, lat#506], [time-lat_time#778, time-lat_lat#779], Inner\n",
      "                     :- *(3) Sort [time#244 ASC NULLS FIRST, lat#506 ASC NULLS FIRST], false, 0\n",
      "                     :  +- Exchange hashpartitioning(time#244, lat#506, 200)\n",
      "                     :     +- *(2) Project [cast(mean_temp#5 as double) AS mean_temp#500, time#244, cast(lat#301 as double) AS lat#506, named_struct(time, time#244, lat, cast(lat#301 as double)) AS time-lat#759]\n",
      "                     :        +- *(2) BroadcastHashJoin [station_number#0], [usaf#295], Inner, BuildRight\n",
      "                     :           :- *(2) Project [station_number#0, mean_temp#5, cast(concat(year#2, -, month#3, -, day#4) as timestamp) AS time#244]\n",
      "                     :           :  +- *(2) Filter (isnotnull(station_number#0) && isnotnull(cast(concat(year#2, -, month#3, -, day#4) as timestamp)))\n",
      "                     :           :     +- *(2) FileScan parquet [station_number#0,year#2,month#3,day#4,mean_temp#5] Batched: true, Format: Parquet, Location: InMemoryFileIndex[gs://w261-data/gsod/data.parquet], PartitionFilters: [], PushedFilters: [IsNotNull(station_number)], ReadSchema: struct<station_number:string,year:string,month:string,day:string,mean_temp:string>\n",
      "                     :           +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, string, true]))\n",
      "                     :              +- *(1) Project [usaf#295, lat#301]\n",
      "                     :                 +- *(1) Filter (((isnotnull(Country#298) && (Country#298 = US)) && isnotnull(usaf#295)) && isnotnull(cast(lat#301 as double)))\n",
      "                     :                    +- *(1) FileScan csv [usaf#295,country#298,lat#301] Batched: false, Format: CSV, Location: InMemoryFileIndex[gs://w261-data/gsod/stations.csv.gz], PartitionFilters: [], PushedFilters: [IsNotNull(country), EqualTo(country,US), IsNotNull(usaf)], ReadSchema: struct<usaf:string,country:string,lat:string>\n",
      "                     +- *(7) Sort [time-lat_time#778 ASC NULLS FIRST, time-lat_lat#779 ASC NULLS FIRST], false, 0\n",
      "                        +- Exchange hashpartitioning(time-lat_time#778, time-lat_lat#779, 200)\n",
      "                           +- *(6) HashAggregate(keys=[time-lat#759], functions=[])\n",
      "                              +- Exchange hashpartitioning(time-lat#759, 200)\n",
      "                                 +- *(5) HashAggregate(keys=[time-lat#759], functions=[])\n",
      "                                    +- *(5) Project [named_struct(time, time#244, lat, cast(lat#301 as double)) AS time-lat#759]\n",
      "                                       +- *(5) BroadcastHashJoin [station_number#0], [usaf#295], Inner, BuildRight, (isnotnull(named_struct(time, time#244, lat, cast(lat#301 as double)).lat) && isnotnull(named_struct(time, time#244, lat, cast(lat#301 as double)).time))\n",
      "                                          :- *(5) Project [station_number#0, cast(concat(year#2, -, month#3, -, day#4) as timestamp) AS time#244]\n",
      "                                          :  +- *(5) Filter isnotnull(station_number#0)\n",
      "                                          :     +- *(5) FileScan parquet [station_number#0,year#2,month#3,day#4] Batched: true, Format: Parquet, Location: InMemoryFileIndex[gs://w261-data/gsod/data.parquet], PartitionFilters: [], PushedFilters: [IsNotNull(station_number)], ReadSchema: struct<station_number:string,year:string,month:string,day:string>\n",
      "                                          +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, string, true]))\n",
      "                                             +- *(4) Project [usaf#295, lat#301]\n",
      "                                                +- *(4) Filter ((isnotnull(Country#298) && (Country#298 = US)) && isnotnull(usaf#295))\n",
      "                                                   +- *(4) FileScan csv [usaf#295,country#298,lat#301] Batched: false, Format: CSV, Location: InMemoryFileIndex[gs://w261-data/gsod/stations.csv.gz], PartitionFilters: [], PushedFilters: [IsNotNull(country), EqualTo(country,US), IsNotNull(usaf)], ReadSchema: struct<usaf:string,country:string,lat:string>\n"
     ]
    }
   ],
   "source": [
    "# oh man that's a lot of stuff and since we can't cache the data this is taking forever to run.\n",
    "# this is similar to the toDebugString() function on RDDs.\n",
    "average_by_lat.explain()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 93,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Let's output to file and then read from that file to reduce our load.\n",
    "average_by_lat.write.format(\"parquet\").save(\"gs://w261-data/gsod/average_by_lat.parquet\")\n",
    "average_by_lat_read = spark.read.parquet(\"gs://w261-data/gsod/average_by_lat.parquet\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 93,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__DISCUSSION__\n",
    "\n",
    "- compare and contrast cache(), save to disk (checkpoint), saveManagedTable"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 93,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 94,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "== Physical Plan ==\n",
      "*(1) FileScan parquet [temp#1070,time#1071,rounded-lat#1072] Batched: true, Format: Parquet, Location: InMemoryFileIndex[gs://w261-data/gsod/average_by_lat.parquet], PartitionFilters: [], PushedFilters: [], ReadSchema: struct<temp:double,time:timestamp,rounded-lat:double>\n"
     ]
    }
   ],
   "source": [
    "average_by_lat_read.explain()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 95,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "+------------------+-------------------+-----------+\n",
      "|              temp|               time|rounded-lat|\n",
      "+------------------+-------------------+-----------+\n",
      "| 37.81914974780793|1938-01-24 00:00:00|       32.0|\n",
      "|35.599998474121094|1938-01-25 00:00:00|       31.0|\n",
      "| 50.68656642401396|1938-04-11 00:00:00|       35.0|\n",
      "|  58.9758634896114|1938-06-10 00:00:00|       40.0|\n",
      "|   65.179345645815|1938-06-16 00:00:00|       39.0|\n",
      "|  71.5999984741211|1938-06-21 00:00:00|       44.0|\n",
      "|   81.929849311487|1938-07-20 00:00:00|       35.0|\n",
      "| 65.32910664876302|1938-08-13 00:00:00|       39.0|\n",
      "| 62.60298572369476|1938-09-06 00:00:00|       35.0|\n",
      "|45.900001525878906|1938-10-18 00:00:00|       45.0|\n",
      "+------------------+-------------------+-----------+\n",
      "only showing top 10 rows\n",
      "\n"
     ]
    }
   ],
   "source": [
    "average_by_lat_read.show(10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 96,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "1395510"
      ]
     },
     "execution_count": 96,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Small enough to fit in pandas for our final analysis. Let's do that\n",
    "average_by_lat_read.count()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 130,
   "metadata": {},
   "outputs": [],
   "source": [
    "df = average_by_lat_read.toPandas()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 131,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>temp</th>\n",
       "      <th>time</th>\n",
       "      <th>rounded-lat</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>37.819150</td>\n",
       "      <td>1938-01-24</td>\n",
       "      <td>32.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>35.599998</td>\n",
       "      <td>1938-01-25</td>\n",
       "      <td>31.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>50.686566</td>\n",
       "      <td>1938-04-11</td>\n",
       "      <td>35.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>58.975863</td>\n",
       "      <td>1938-06-10</td>\n",
       "      <td>40.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>65.179346</td>\n",
       "      <td>1938-06-16</td>\n",
       "      <td>39.0</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "        temp       time  rounded-lat\n",
       "0  37.819150 1938-01-24         32.0\n",
       "1  35.599998 1938-01-25         31.0\n",
       "2  50.686566 1938-04-11         35.0\n",
       "3  58.975863 1938-06-10         40.0\n",
       "4  65.179346 1938-06-16         39.0"
      ]
     },
     "execution_count": 131,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 132,
   "metadata": {},
   "outputs": [],
   "source": [
    "df = df.set_index(['rounded-lat','time'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 133,
   "metadata": {},
   "outputs": [],
   "source": [
    "df = df.sort_index()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 134,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th>temp</th>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>rounded-lat</th>\n",
       "      <th>time</th>\n",
       "      <th></th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th rowspan=\"5\" valign=\"top\">-60.0</th>\n",
       "      <th>1943-08-01</th>\n",
       "      <td>55.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1943-08-02</th>\n",
       "      <td>56.200001</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1943-08-03</th>\n",
       "      <td>60.099998</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1943-08-04</th>\n",
       "      <td>56.700001</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1943-08-05</th>\n",
       "      <td>57.700001</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "                             temp\n",
       "rounded-lat time                 \n",
       "-60.0       1943-08-01  55.000000\n",
       "            1943-08-02  56.200001\n",
       "            1943-08-03  60.099998\n",
       "            1943-08-04  56.700001\n",
       "            1943-08-05  57.700001"
      ]
     },
     "execution_count": 134,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 160,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Float64Index([-60.0, -35.0, -32.0, -18.0, -10.0,   0.0,   4.0,   6.0,   9.0,\n",
      "               15.0,  17.0,  18.0,  19.0,  20.0,  21.0,  22.0,  23.0,  24.0,\n",
      "               25.0,  26.0,  27.0,  28.0,  29.0,  30.0,  31.0,  32.0,  33.0,\n",
      "               34.0,  35.0,  36.0,  37.0,  38.0,  39.0,  40.0,  41.0,  42.0,\n",
      "               43.0,  44.0,  45.0,  46.0,  47.0,  48.0,  49.0,  50.0,  51.0,\n",
      "               52.0,  53.0,  54.0,  55.0,  56.0,  57.0,  58.0,  59.0,  60.0,\n",
      "               61.0,  62.0,  63.0,  64.0,  65.0,  66.0,  67.0,  68.0,  69.0,\n",
      "               70.0,  71.0,  72.0,  80.0,  84.0],\n",
      "             dtype='float64', name='rounded-lat')\n"
     ]
    }
   ],
   "source": [
    "lat_list = df.index.levels[0]\n",
    "print(lat_list)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 159,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "3e5af30b36e641468dc19fc8d7ee357a",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "interactive(children=(Dropdown(description='x', options=(-60.0, -35.0, -32.0, -18.0, -10.0, 0.0, 4.0, 6.0, 9.0…"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Is temperature increasing? Data isn't very clean and we didn't perform any sensor corrections.\n",
    "%matplotlib notebook\n",
    "from ipywidgets import *\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "n_roll = 365\n",
    "def f(x):\n",
    "    df.loc[x].rolling(n_roll).mean().plot()\n",
    "\n",
    "interact(f, x=lat_list);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> __DISCUSSION QUESTIONS:__\n",
    "* Why did we create a struct for our groupBy?\n",
    "* Why did we push our transformations to a file and load them again?\n",
    "* Where could we have done this before to save computation time?\n",
    "* Why did we do a rolling average of temperature?\n",
    "* Isn't pandas a lot easier to use?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__INSTRUCTOR TALKING POINTS__\n",
    "* Why did we create a struct for our groupBy?\n",
    "> This allowed us to create a composite key that we can access the original keys in a seamless fashion\n",
    "\n",
    "* Why did we push our transformations to a file and load them again?\n",
    "> This offload allowed us to have non-repeated computation once we went through the transformation steps. \n",
    "\n",
    "* Where could we have done this before to save computation time?\n",
    "> We could have done a similar file offload prior to generating our histograms that repeated the computation 3x.\n",
    "\n",
    "* Why did we do a rolling average of the temprature?\n",
    "> We only care about the long term change in temperature and the day to day variations are dependent on various weather effects such as rain or clouds.\n",
    "\n",
    "* Isn't pandas a lot easier to use?\n",
    "> Yes, but it also has significant limitations in comparison to the raw data we're able to process with Spark. \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<img src=\"../screenshots/lost-proxy.png\">"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.6"
  },
  "toc": {
   "colors": {
    "hover_highlight": "#DAA520",
    "navigate_num": "#000000",
    "navigate_text": "#333333",
    "running_highlight": "#FF0000",
    "selected_highlight": "#FFD700",
    "sidebar_border": "#EEEEEE",
    "wrapper_background": "#FFFFFF"
   },
   "moveMenuLeft": true,
   "nav_menu": {
    "height": "462px",
    "width": "252px"
   },
   "navigate_menu": true,
   "number_sections": true,
   "sideBar": true,
   "threshold": 4,
   "toc_cell": true,
   "toc_position": {
    "height": "567px",
    "left": "0px",
    "right": "707.4456787109375px",
    "top": "105px",
    "width": "243px"
   },
   "toc_section_display": "block",
   "toc_window_display": true,
   "widenNotebook": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
